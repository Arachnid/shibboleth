{
  "address": "0xa189bD49b29630469452329b7c70FEd8974E0DF0",
  "abi": [
    {
      "inputs": [],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "CreateFail",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "creator",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "nonce",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "instance",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "Cloned",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "nonce",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "address[]",
          "name": "issuers",
          "type": "address[]"
        }
      ],
      "name": "create",
      "outputs": [
        {
          "internalType": "contract ERC20UniqueNonceValidator",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "implementation",
      "outputs": [
        {
          "internalType": "contract ERC20UniqueNonceValidator",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xa803b4149954df1a268dde85e2644bf9294546ba8610b07d820b00ba14c87a70",
  "receipt": {
    "to": null,
    "from": "0xE0b604208176C9c991A310E242677dfFddd3ab4D",
    "contractAddress": "0xa189bD49b29630469452329b7c70FEd8974E0DF0",
    "transactionIndex": 6,
    "gasUsed": "2456140",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x1f730df51bb9df96b462ad96d870488ff5afa2d6e002a9aca9a949f3f47ae3c3",
    "transactionHash": "0xa803b4149954df1a268dde85e2644bf9294546ba8610b07d820b00ba14c87a70",
    "logs": [],
    "blockNumber": 10136940,
    "cumulativeGasUsed": "2792262",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 2,
  "solcInputHash": "eb59c181ab9e5d2b5dbb7f0829fade39",
  "metadata": "{\"compiler\":{\"version\":\"0.8.10+commit.fc410830\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CreateFail\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"instance\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Cloned\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"issuers\",\"type\":\"address[]\"}],\"name\":\"create\",\"outputs\":[{\"internalType\":\"contract ERC20UniqueNonceValidator\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"contract ERC20UniqueNonceValidator\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/factories/ERC20UniqueNonceValidator.sol\":\"ERC20UniqueNonceValidatorFactory\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"@ensdomains/buffer/contracts/Buffer.sol\":{\"content\":\"pragma solidity ^0.8.4;\\n\\n/**\\n* @dev A library for working with mutable byte buffers in Solidity.\\n*\\n* Byte buffers are mutable and expandable, and provide a variety of primitives\\n* for writing to them. At any time you can fetch a bytes object containing the\\n* current contents of the buffer. The bytes object should not be stored between\\n* operations, as it may change due to resizing of the buffer.\\n*/\\nlibrary Buffer {\\n    /**\\n    * @dev Represents a mutable buffer. Buffers have a current value (buf) and\\n    *      a capacity. The capacity may be longer than the current value, in\\n    *      which case it can be extended without the need to allocate more memory.\\n    */\\n    struct buffer {\\n        bytes buf;\\n        uint capacity;\\n    }\\n\\n    /**\\n    * @dev Initializes a buffer with an initial capacity.\\n    * @param buf The buffer to initialize.\\n    * @param capacity The number of bytes of space to allocate the buffer.\\n    * @return The buffer, for chaining.\\n    */\\n    function init(buffer memory buf, uint capacity) internal pure returns(buffer memory) {\\n        if (capacity % 32 != 0) {\\n            capacity += 32 - (capacity % 32);\\n        }\\n        // Allocate space for the buffer data\\n        buf.capacity = capacity;\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(buf, ptr)\\n            mstore(ptr, 0)\\n            mstore(0x40, add(32, add(ptr, capacity)))\\n        }\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Initializes a new buffer from an existing bytes object.\\n    *      Changes to the buffer may mutate the original value.\\n    * @param b The bytes object to initialize the buffer with.\\n    * @return A new buffer.\\n    */\\n    function fromBytes(bytes memory b) internal pure returns(buffer memory) {\\n        buffer memory buf;\\n        buf.buf = b;\\n        buf.capacity = b.length;\\n        return buf;\\n    }\\n\\n    function resize(buffer memory buf, uint capacity) private pure {\\n        bytes memory oldbuf = buf.buf;\\n        init(buf, capacity);\\n        append(buf, oldbuf);\\n    }\\n\\n    function max(uint a, uint b) private pure returns(uint) {\\n        if (a > b) {\\n            return a;\\n        }\\n        return b;\\n    }\\n\\n    /**\\n    * @dev Sets buffer length to 0.\\n    * @param buf The buffer to truncate.\\n    * @return The original buffer, for chaining..\\n    */\\n    function truncate(buffer memory buf) internal pure returns (buffer memory) {\\n        assembly {\\n            let bufptr := mload(buf)\\n            mstore(bufptr, 0)\\n        }\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param off The start offset to write to.\\n    * @param data The data to append.\\n    * @param len The number of bytes to copy.\\n    * @return The original buffer, for chaining.\\n    */\\n    function write(buffer memory buf, uint off, bytes memory data, uint len) internal pure returns(buffer memory) {\\n        require(len <= data.length);\\n\\n        if (off + len > buf.capacity) {\\n            resize(buf, max(buf.capacity, len + off) * 2);\\n        }\\n\\n        uint dest;\\n        uint src;\\n        assembly {\\n            // Memory address of the buffer data\\n            let bufptr := mload(buf)\\n            // Length of existing buffer data\\n            let buflen := mload(bufptr)\\n            // Start address = buffer address + offset + sizeof(buffer length)\\n            dest := add(add(bufptr, 32), off)\\n            // Update buffer length if we're extending it\\n            if gt(add(len, off), buflen) {\\n                mstore(bufptr, add(len, off))\\n            }\\n            src := add(data, 32)\\n        }\\n\\n        // Copy word-length chunks while possible\\n        for (; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        // Copy remaining bytes\\n        unchecked {\\n            uint mask = (256 ** (32 - len)) - 1;\\n            assembly {\\n                let srcpart := and(mload(src), not(mask))\\n                let destpart := and(mload(dest), mask)\\n                mstore(dest, or(destpart, srcpart))\\n            }\\n        }\\n\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @param len The number of bytes to copy.\\n    * @return The original buffer, for chaining.\\n    */\\n    function append(buffer memory buf, bytes memory data, uint len) internal pure returns (buffer memory) {\\n        return write(buf, buf.buf.length, data, len);\\n    }\\n\\n    /**\\n    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer, for chaining.\\n    */\\n    function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\\n        return write(buf, buf.buf.length, data, data.length);\\n    }\\n\\n    /**\\n    * @dev Writes a byte to the buffer. Resizes if doing so would exceed the\\n    *      capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param off The offset to write the byte at.\\n    * @param data The data to append.\\n    * @return The original buffer, for chaining.\\n    */\\n    function writeUint8(buffer memory buf, uint off, uint8 data) internal pure returns(buffer memory) {\\n        if (off >= buf.capacity) {\\n            resize(buf, buf.capacity * 2);\\n        }\\n\\n        assembly {\\n            // Memory address of the buffer data\\n            let bufptr := mload(buf)\\n            // Length of existing buffer data\\n            let buflen := mload(bufptr)\\n            // Address = buffer address + sizeof(buffer length) + off\\n            let dest := add(add(bufptr, off), 32)\\n            mstore8(dest, data)\\n            // Update buffer length if we extended it\\n            if eq(off, buflen) {\\n                mstore(bufptr, add(buflen, 1))\\n            }\\n        }\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\\n    *      capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer, for chaining.\\n    */\\n    function appendUint8(buffer memory buf, uint8 data) internal pure returns(buffer memory) {\\n        return writeUint8(buf, buf.buf.length, data);\\n    }\\n\\n    /**\\n    * @dev Writes up to 32 bytes to the buffer. Resizes if doing so would\\n    *      exceed the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param off The offset to write at.\\n    * @param data The data to append.\\n    * @param len The number of bytes to write (left-aligned).\\n    * @return The original buffer, for chaining.\\n    */\\n    function write(buffer memory buf, uint off, bytes32 data, uint len) private pure returns(buffer memory) {\\n        if (len + off > buf.capacity) {\\n            resize(buf, (len + off) * 2);\\n        }\\n\\n        unchecked {\\n            uint mask = (256 ** len) - 1;\\n            // Right-align data\\n            data = data >> (8 * (32 - len));\\n            assembly {\\n                // Memory address of the buffer data\\n                let bufptr := mload(buf)\\n                // Address = buffer address + sizeof(buffer length) + off + len\\n                let dest := add(add(bufptr, off), len)\\n                mstore(dest, or(and(mload(dest), not(mask)), data))\\n                // Update buffer length if we extended it\\n                if gt(add(off, len), mload(bufptr)) {\\n                    mstore(bufptr, add(off, len))\\n                }\\n            }\\n        }\\n        return buf;\\n    }\\n\\n    /**\\n    * @dev Writes a bytes20 to the buffer. Resizes if doing so would exceed the\\n    *      capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param off The offset to write at.\\n    * @param data The data to append.\\n    * @return The original buffer, for chaining.\\n    */\\n    function writeBytes20(buffer memory buf, uint off, bytes20 data) internal pure returns (buffer memory) {\\n        return write(buf, off, bytes32(data), 20);\\n    }\\n\\n    /**\\n    * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer, for chhaining.\\n    */\\n    function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\\n        return write(buf, buf.buf.length, bytes32(data), 20);\\n    }\\n\\n    /**\\n    * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param data The data to append.\\n    * @return The original buffer, for chaining.\\n    */\\n    function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\\n        return write(buf, buf.buf.length, data, 32);\\n    }\\n\\n    /**\\n    * @dev Writes an integer to the buffer. Resizes if doing so would exceed\\n    *      the capacity of the buffer.\\n    * @param buf The buffer to append to.\\n    * @param off The offset to write at.\\n    * @param data The data to append.\\n    * @param len The number of bytes to write (right-aligned).\\n    * @return The original buffer, for chaining.\\n    */\\n    function writeInt(buffer memory buf, uint off, uint data, uint len) private pure returns(buffer memory) {\\n        if (len + off > buf.capacity) {\\n            resize(buf, (len + off) * 2);\\n        }\\n\\n        uint mask = (256 ** len) - 1;\\n        assembly {\\n            // Memory address of the buffer data\\n            let bufptr := mload(buf)\\n            // Address = buffer address + off + sizeof(buffer length) + len\\n            let dest := add(add(bufptr, off), len)\\n            mstore(dest, or(and(mload(dest), not(mask)), data))\\n            // Update buffer length if we extended it\\n            if gt(add(off, len), mload(bufptr)) {\\n                mstore(bufptr, add(off, len))\\n            }\\n        }\\n        return buf;\\n    }\\n\\n    /**\\n     * @dev Appends a byte to the end of the buffer. Resizes if doing so would\\n     * exceed the capacity of the buffer.\\n     * @param buf The buffer to append to.\\n     * @param data The data to append.\\n     * @return The original buffer.\\n     */\\n    function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\\n        return writeInt(buf, buf.buf.length, data, len);\\n    }\\n}\\n\",\"keccak256\":\"0x18e42be1a3e4f7b4442d7ab0b524af5e09163503439954faf0ab3792cce91caa\"},\"@openzeppelin/contracts/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0x61437cb513a887a1bbad006e7b1c8b414478427d33de47c5600af3c748f108da\",\"license\":\"MIT\"},\"@openzeppelin/contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x8de418a5503946cabe331f35fe242d3201a73f67f77aaeb7110acb1f30423aca\",\"license\":\"MIT\"},\"@openzeppelin/contracts/contracts/utils/Base64.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides a set of functions to operate with Base64 strings.\\n */\\nlibrary Base64 {\\n    /**\\n     * @dev Base64 Encoding/Decoding Table\\n     */\\n    string internal constant _TABLE = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n\\n    /**\\n     * @dev Converts a `bytes` to its Bytes64 `string` representation.\\n     */\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        /**\\n         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\\n         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\\n         */\\n        if (data.length == 0) return \\\"\\\";\\n\\n        // Loads the table into memory\\n        string memory table = _TABLE;\\n\\n        // Encoding takes 3 bytes chunks of binary data from `bytes` data parameter\\n        // and split into 4 numbers of 6 bits.\\n        // The final Base64 length should be `bytes` data length multiplied by 4/3 rounded up\\n        // - `data.length + 2`  -> Round up\\n        // - `/ 3`              -> Number of 3-bytes chunks\\n        // - `4 *`              -> 4 characters for each chunk\\n        string memory result = new string(4 * ((data.length + 2) / 3));\\n\\n        assembly {\\n            // Prepare the lookup table (skip the first \\\"length\\\" byte)\\n            let tablePtr := add(table, 1)\\n\\n            // Prepare result pointer, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // Run over the input, 3 bytes at a time\\n            for {\\n                let dataPtr := data\\n                let endPtr := add(data, mload(data))\\n            } lt(dataPtr, endPtr) {\\n\\n            } {\\n                // Advance 3 bytes\\n                dataPtr := add(dataPtr, 3)\\n                let input := mload(dataPtr)\\n\\n                // To write each character, shift the 3 bytes (18 bits) chunk\\n                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\\n                // and apply logical AND with 0x3F which is the number of\\n                // the previous character in the ASCII table prior to the Base64 Table\\n                // The result is then added to the table to get the character to write,\\n                // and finally write it in the result pointer but with a left shift\\n                // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n            }\\n\\n            // When data `bytes` is not exactly 3 bytes long\\n            // it is padded with `=` characters at the end\\n            switch mod(mload(data), 3)\\n            case 1 {\\n                mstore8(sub(resultPtr, 1), 0x3d)\\n                mstore8(sub(resultPtr, 2), 0x3d)\\n            }\\n            case 2 {\\n                mstore8(sub(resultPtr, 1), 0x3d)\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\",\"keccak256\":\"0x1157a957a0fa2c8a8e93be4397ed06e393524fc317d85bbc868f558ee33c80c4\",\"license\":\"MIT\"},\"@openzeppelin/contracts/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\",\"keccak256\":\"0x32c202bd28995dd20c4347b7c6467a6d3241c74c8ad3edcbb610cd9205916c45\",\"license\":\"MIT\"},\"@openzeppelin/contracts/contracts/utils/cryptography/ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        } else if (error == RecoverError.InvalidSignatureV) {\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        // Check the signature length\\n        // - case 65: r,s,v signature (standard)\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else if (signature.length == 64) {\\n            bytes32 r;\\n            bytes32 vs;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                vs := mload(add(signature, 0x40))\\n            }\\n            return tryRecover(hash, r, vs);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \\u00f7 2 + 1, and for v in (302): v \\u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n        if (v != 27 && v != 28) {\\n            return (address(0), RecoverError.InvalidSignatureV);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\",\"keccak256\":\"0x5adb19e266fcbc76fb4f232e6879932859de1fd1023f6aabaf8da3606c824080\",\"license\":\"MIT\"},\"@openzeppelin/contracts/contracts/utils/introspection/ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\",\"keccak256\":\"0xd10975de010d89fd1c78dc5e8a9a7e7f496198085c151648f20cba166b32582b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/contracts/utils/structs/BitMaps.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/structs/BitMaps.sol)\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing uint256 to bool mapping in a compact and efficient way, providing the keys are sequential.\\n * Largelly inspired by Uniswap's https://github.com/Uniswap/merkle-distributor/blob/master/contracts/MerkleDistributor.sol[merkle-distributor].\\n */\\nlibrary BitMaps {\\n    struct BitMap {\\n        mapping(uint256 => uint256) _data;\\n    }\\n\\n    /**\\n     * @dev Returns whether the bit at `index` is set.\\n     */\\n    function get(BitMap storage bitmap, uint256 index) internal view returns (bool) {\\n        uint256 bucket = index >> 8;\\n        uint256 mask = 1 << (index & 0xff);\\n        return bitmap._data[bucket] & mask != 0;\\n    }\\n\\n    /**\\n     * @dev Sets the bit at `index` to the boolean `value`.\\n     */\\n    function setTo(\\n        BitMap storage bitmap,\\n        uint256 index,\\n        bool value\\n    ) internal {\\n        if (value) {\\n            set(bitmap, index);\\n        } else {\\n            unset(bitmap, index);\\n        }\\n    }\\n\\n    /**\\n     * @dev Sets the bit at `index`.\\n     */\\n    function set(BitMap storage bitmap, uint256 index) internal {\\n        uint256 bucket = index >> 8;\\n        uint256 mask = 1 << (index & 0xff);\\n        bitmap._data[bucket] |= mask;\\n    }\\n\\n    /**\\n     * @dev Unsets the bit at `index`.\\n     */\\n    function unset(BitMap storage bitmap, uint256 index) internal {\\n        uint256 bucket = index >> 8;\\n        uint256 mask = 1 << (index & 0xff);\\n        bitmap._data[bucket] &= ~mask;\\n    }\\n}\\n\",\"keccak256\":\"0xc5d14e1780f0ea212b19c07b83c8e51b9dc6903017df71e6de1fae364d724e0d\",\"license\":\"MIT\"},\"clones-with-immutable-args/Clone.sol\":{\"content\":\"// SPDX-License-Identifier: BSD\\npragma solidity ^0.8.4;\\n\\n/// @title Clone\\n/// @author zefram.eth\\n/// @notice Provides helper functions for reading immutable args from calldata\\ncontract Clone {\\n    /// @notice Reads an immutable arg with type address\\n    /// @param argOffset The offset of the arg in the packed data\\n    /// @return arg The arg value\\n    function _getArgAddress(uint256 argOffset)\\n        internal\\n        pure\\n        returns (address arg)\\n    {\\n        uint256 offset = _getImmutableArgsOffset();\\n        assembly {\\n            arg := shr(0x60, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @notice Reads an immutable arg with type uint256\\n    /// @param argOffset The offset of the arg in the packed data\\n    /// @return arg The arg value\\n    function _getArgUint256(uint256 argOffset)\\n        internal\\n        pure\\n        returns (uint256 arg)\\n    {\\n        uint256 offset = _getImmutableArgsOffset();\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            arg := calldataload(add(offset, argOffset))\\n        }\\n    }\\n\\n    /// @notice Reads an immutable arg with type uint64\\n    /// @param argOffset The offset of the arg in the packed data\\n    /// @return arg The arg value\\n    function _getArgUint64(uint256 argOffset)\\n        internal\\n        pure\\n        returns (uint64 arg)\\n    {\\n        uint256 offset = _getImmutableArgsOffset();\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            arg := shr(0xc0, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @notice Reads an immutable arg with type uint8\\n    /// @param argOffset The offset of the arg in the packed data\\n    /// @return arg The arg value\\n    function _getArgUint8(uint256 argOffset) internal pure returns (uint8 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            arg := shr(0xf8, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @return offset The offset of the packed immutable args in calldata\\n    function _getImmutableArgsOffset() internal pure returns (uint256 offset) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            offset := sub(\\n                calldatasize(),\\n                add(shr(240, calldataload(sub(calldatasize(), 2))), 2)\\n            )\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x8f569b077d99ec821c2750c52094b59b3505fb6ca3e6eac9009092bf86c5452d\",\"license\":\"BSD\"},\"clones-with-immutable-args/ClonesWithImmutableArgs.sol\":{\"content\":\"// SPDX-License-Identifier: BSD\\n\\npragma solidity ^0.8.4;\\n\\n/// @title ClonesWithImmutableArgs\\n/// @author wighawag, zefram.eth\\n/// @notice Enables creating clone contracts with immutable args\\nlibrary ClonesWithImmutableArgs {\\n    error CreateFail();\\n\\n    /// @notice Creates a clone proxy of the implementation contract, with immutable args\\n    /// @dev data cannot exceed 65535 bytes, since 2 bytes are used to store the data length\\n    /// @param implementation The implementation contract to clone\\n    /// @param data Encoded immutable args\\n    /// @return instance The address of the created clone\\n    function clone(address implementation, bytes memory data)\\n        internal\\n        returns (address instance)\\n    {\\n        // unrealistic for memory ptr or data length to exceed 256 bits\\n        unchecked {\\n            uint256 extraLength = data.length + 2; // +2 bytes for telling how much data there is appended to the call\\n            uint256 creationSize = 0x43 + extraLength;\\n            uint256 runSize = creationSize - 11;\\n            uint256 dataPtr;\\n            uint256 ptr;\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                ptr := mload(0x40)\\n\\n                // -------------------------------------------------------------------------------------------------------------\\n                // CREATION (11 bytes)\\n                // -------------------------------------------------------------------------------------------------------------\\n\\n                // 3d          | RETURNDATASIZE        | 0                       | \\u2013\\n                // 61 runtime  | PUSH2 runtime (r)     | r 0                     | \\u2013\\n                mstore(\\n                    ptr,\\n                    0x3d61000000000000000000000000000000000000000000000000000000000000\\n                )\\n                mstore(add(ptr, 0x02), shl(240, runSize)) // size of the contract running bytecode (16 bits)\\n\\n                // creation size = 0b\\n                // 80          | DUP1                  | r r 0                   | \\u2013\\n                // 60 creation | PUSH1 creation (c)    | c r r 0                 | \\u2013\\n                // 3d          | RETURNDATASIZE        | 0 c r r 0               | \\u2013\\n                // 39          | CODECOPY              | r 0                     | [0-2d]: runtime code\\n                // 81          | DUP2                  | 0 c  0                  | [0-2d]: runtime code\\n                // f3          | RETURN                | 0                       | [0-2d]: runtime code\\n                mstore(\\n                    add(ptr, 0x04),\\n                    0x80600b3d3981f300000000000000000000000000000000000000000000000000\\n                )\\n\\n                // -------------------------------------------------------------------------------------------------------------\\n                // RUNTIME\\n                // -------------------------------------------------------------------------------------------------------------\\n\\n                // 36          | CALLDATASIZE          | cds                     | \\u2013\\n                // 3d          | RETURNDATASIZE        | 0 cds                   | \\u2013\\n                // 3d          | RETURNDATASIZE        | 0 0 cds                 | \\u2013\\n                // 37          | CALLDATACOPY          | \\u2013                       | [0, cds] = calldata\\n                // 61          | PUSH2 extra           | extra                   | [0, cds] = calldata\\n                mstore(\\n                    add(ptr, 0x0b),\\n                    0x363d3d3761000000000000000000000000000000000000000000000000000000\\n                )\\n                mstore(add(ptr, 0x10), shl(240, extraLength))\\n\\n                // 60 0x38     | PUSH1 0x38            | 0x38 extra              | [0, cds] = calldata // 0x38 (56) is runtime size - data\\n                // 36          | CALLDATASIZE          | cds 0x38 extra          | [0, cds] = calldata\\n                // 39          | CODECOPY              | _                       | [0, cds] = calldata\\n                // 3d          | RETURNDATASIZE        | 0                       | [0, cds] = calldata\\n                // 3d          | RETURNDATASIZE        | 0 0                     | [0, cds] = calldata\\n                // 3d          | RETURNDATASIZE        | 0 0 0                   | [0, cds] = calldata\\n                // 36          | CALLDATASIZE          | cds 0 0 0               | [0, cds] = calldata\\n                // 61 extra    | PUSH2 extra           | extra cds 0 0 0         | [0, cds] = calldata\\n                mstore(\\n                    add(ptr, 0x12),\\n                    0x603836393d3d3d36610000000000000000000000000000000000000000000000\\n                )\\n                mstore(add(ptr, 0x1b), shl(240, extraLength))\\n\\n                // 01          | ADD                   | cds+extra 0 0 0         | [0, cds] = calldata\\n                // 3d          | RETURNDATASIZE        | 0 cds 0 0 0             | [0, cds] = calldata\\n                // 73 addr     | PUSH20 0x123\\u2026         | addr 0 cds 0 0 0        | [0, cds] = calldata\\n                mstore(\\n                    add(ptr, 0x1d),\\n                    0x013d730000000000000000000000000000000000000000000000000000000000\\n                )\\n                mstore(add(ptr, 0x20), shl(0x60, implementation))\\n\\n                // 5a          | GAS                   | gas addr 0 cds 0 0 0    | [0, cds] = calldata\\n                // f4          | DELEGATECALL          | success 0               | [0, cds] = calldata\\n                // 3d          | RETURNDATASIZE        | rds success 0           | [0, cds] = calldata\\n                // 82          | DUP3                  | 0 rds success 0         | [0, cds] = calldata\\n                // 80          | DUP1                  | 0 0 rds success 0       | [0, cds] = calldata\\n                // 3e          | RETURNDATACOPY        | success 0               | [0, rds] = return data (there might be some irrelevant leftovers in memory [rds, cds] when rds < cds)\\n                // 90          | SWAP1                 | 0 success               | [0, rds] = return data\\n                // 3d          | RETURNDATASIZE        | rds 0 success           | [0, rds] = return data\\n                // 91          | SWAP2                 | success 0 rds           | [0, rds] = return data\\n                // 60 0x36     | PUSH1 0x36            | 0x36 sucess 0 rds       | [0, rds] = return data\\n                // 57          | JUMPI                 | 0 rds                   | [0, rds] = return data\\n                // fd          | REVERT                | \\u2013                       | [0, rds] = return data\\n                // 5b          | JUMPDEST              | 0 rds                   | [0, rds] = return data\\n                // f3          | RETURN                | \\u2013                       | [0, rds] = return data\\n\\n                mstore(\\n                    add(ptr, 0x34),\\n                    0x5af43d82803e903d91603657fd5bf30000000000000000000000000000000000\\n                )\\n            }\\n\\n            // -------------------------------------------------------------------------------------------------------------\\n            // APPENDED DATA (Accessible from extcodecopy)\\n            // (but also send as appended data to the delegatecall)\\n            // -------------------------------------------------------------------------------------------------------------\\n\\n            extraLength -= 2;\\n            uint256 counter = extraLength;\\n            uint256 copyPtr = ptr + 0x43;\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                dataPtr := add(data, 32)\\n            }\\n            for (; counter >= 32; counter -= 32) {\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    mstore(copyPtr, mload(dataPtr))\\n                }\\n\\n                copyPtr += 32;\\n                dataPtr += 32;\\n            }\\n            uint256 mask = ~(256**(32 - counter) - 1);\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                mstore(copyPtr, and(mload(dataPtr), mask))\\n            }\\n            copyPtr += counter;\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                mstore(copyPtr, shl(240, extraLength))\\n            }\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                instance := create(0, ptr, creationSize)\\n            }\\n            if (instance == address(0)) {\\n                revert CreateFail();\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x0c6a218a9724ce6d754db22b162600adbdbac41bfe4dd4eecf6b6d77c74eefe7\",\"license\":\"BSD\"},\"contracts/BaseValidator.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\nimport \\\"@openzeppelin/contracts/contracts/utils/introspection/ERC165.sol\\\";\\nimport \\\"@openzeppelin/contracts/contracts/utils/Base64.sol\\\";\\nimport \\\"./ValidatorLib.sol\\\";\\nimport \\\"./IValidator.sol\\\";\\n\\nabstract contract BaseValidator is IValidator, ERC165 {\\n    error UnauthorisedIssuer(address issuer);\\n    error NotAuthorised();\\n\\n    function isIssuer(address issuer) internal virtual view returns(bool);\\n\\n    function isOwner(address owner) public virtual view returns(bool);\\n\\n    modifier ownerOnly {\\n        if(!isOwner(msg.sender)) {\\n            revert NotAuthorised();\\n        }\\n        _;\\n    }\\n\\n    function claim(address beneficiary, bytes calldata data, bytes calldata authsig, bytes calldata claimsig) public override virtual returns(address issuer, address claimant) {\\n        (issuer, claimant) = ValidatorLib.validate(address(this), beneficiary, data, authsig, claimsig);\\n        if(!isIssuer(issuer)) {\\n            revert UnauthorisedIssuer(issuer);\\n        }\\n        emit ClaimExecuted(keccak256(authsig), issuer, beneficiary, metadata(issuer, claimant, data));\\n    }\\n\\n    function metadata(address issuer, address claimant, bytes calldata data) public override virtual view returns(bytes memory);\\n\\n    function isExecutable(address issuer, address /*claimant*/, bytes calldata /*data*/) public virtual view returns(bool) {\\n        return isIssuer(issuer);\\n    }\\n}\\n\",\"keccak256\":\"0xf02148be44f7be17ffcde94ffb24d45667e76e341312c12e3be4aad6ccbe134d\",\"license\":\"MIT\"},\"contracts/IValidator.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\nimport \\\"@openzeppelin/contracts/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Interface for a Shibboleth validator.\\n *      Shibboleth validators are responsible for verifying and acting on single-use claim codes issued by offchain authorities.\\n */\\ninterface IValidator is IERC165 {\\n    /**\\n     * @dev Executes a claim transaction as specified in https://gist.github.com/Arachnid/df9c7e3738ee76bf171c46ef38e4f18b\\n     * @param beneficiary The address that the claim should benefit.\\n     * @param data Claim data provided by the issuer.\\n     * @param authsig A signature over the authorisation message, produced by the issuer.\\n     * @param claimsig A signature over the claim message, produced by the client.\\n     * @return issuer The address of the issuer for this claim.\\n     * @return claimant The address of the claimant for this claim.\\n     */\\n    function claim(address beneficiary, bytes calldata data, bytes calldata authsig, bytes calldata claimsig) external returns(address issuer, address claimant);\\n\\n    /**\\n     * @dev Indicates if a claim can be executed or not.\\n     * @param issuer The address of the issuer.\\n     * @param claimant The account that is entitled to make the claim.\\n     * @param data Claim data provided by the issuer.\\n     * @return True iff a call to claim() would succeed, false otherwise.\\n     */\\n    function isExecutable(address issuer, address claimant, bytes calldata data) external view returns(bool);\\n\\n    /**\\n     * @dev Returns metadata explaining a claim.\\n     * @param issuer The address of the issuer.\\n     * @param claimant The account that is entitled to make the claim.\\n     * @param data Claim data provided by the issuer.\\n     * @return CBOR-encoded metadata as described in the spec.\\n     */\\n    function metadata(address issuer, address claimant, bytes calldata data) external view returns(bytes memory);\\n    \\n    event ClaimExecuted(bytes32 indexed claimId, address indexed issuer, address beneficiary, bytes metadata);\\n}\\n\",\"keccak256\":\"0x82d43e686d308821f62caefdb0233775ac2cc39b7be8c86f01bb9a34e763c7d6\",\"license\":\"MIT\"},\"contracts/ValidatorLib.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\nimport \\\"@openzeppelin/contracts/contracts/utils/cryptography/ECDSA.sol\\\";\\n\\nlibrary ValidatorLib {\\n  function validate(address validator, address beneficiary, bytes calldata data, bytes calldata authsig, bytes calldata claimsig) internal pure returns(address, address) {\\n        bytes32 claimhash = keccak256(abi.encodePacked(\\n            hex\\\"1900\\\",\\n            validator,\\n            hex\\\"80\\\",\\n            keccak256(authsig),\\n            beneficiary\\n        ));\\n        address claimant = ECDSA.recover(claimhash, claimsig);\\n        bytes32 authhash = keccak256(abi.encodePacked(\\n            hex\\\"1900\\\",\\n            validator,\\n            hex\\\"00\\\",\\n            keccak256(data),\\n            claimant\\n        ));\\n        address issuer = ECDSA.recover(authhash, authsig);\\n        return (issuer, claimant);\\n    }\\n}\\n\",\"keccak256\":\"0xff1916adb246b347fd0f503014938604f3a72bb27ef00e97fbb6ffb9fbdf7ac9\",\"license\":\"MIT\"},\"contracts/auths/IssuerWhitelistAuth.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\nimport \\\"../BaseValidator.sol\\\";\\nimport \\\"@openzeppelin/contracts/contracts/utils/Base64.sol\\\";\\n\\n/**\\n * Abstract implementation of a validator that maintains a whitelist of allowed issuers.\\n */\\nabstract contract IssuerWhitelistAuth is BaseValidator {\\n    mapping(address=>bool) public issuers;\\n\\n    event IssuersAdded(address[] issuers);\\n    event IssuersRemoved(address[] issuers);\\n\\n    function isIssuer(address issuer) internal override virtual view returns(bool) {\\n        return issuers[issuer];\\n    }\\n\\n    function addIssuers(address[] memory _issuers) external ownerOnly {\\n        for(uint256 i = 0; i < _issuers.length; i++) {\\n            issuers[_issuers[i]] = true;\\n        }\\n        emit IssuersAdded(_issuers);\\n    }\\n\\n    function removeIssuers(address[] calldata _issuers) external ownerOnly {\\n        for(uint256 i = 0; i < _issuers.length; i++) {\\n            issuers[_issuers[i]] = false;\\n        }\\n        emit IssuersRemoved(_issuers);\\n    }\\n}\\n\",\"keccak256\":\"0x5537c8614ff0650a5ed8108f95b8ca5f22df5890c225c32fc5441cc7a3f093de\",\"license\":\"MIT\"},\"contracts/dedups/UniqueNonceDedup.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\nimport \\\"../BaseValidator.sol\\\";\\nimport \\\"@openzeppelin/contracts/contracts/utils/Base64.sol\\\";\\nimport \\\"@openzeppelin/contracts/contracts/utils/structs/BitMaps.sol\\\";\\n\\n/**\\n * @dev An implementation of a Validator that requires each claim to have a unique nonce,\\n *      encoded as a uint256 in the first 32 bytes of the data field.\\n */\\nabstract contract UniqueNonceDedup is BaseValidator {\\n    using BitMaps for BitMaps.BitMap;\\n\\n    mapping(address=>BitMaps.BitMap) nonces;\\n\\n    error NonceAlreadyUsed(uint256 nonce);\\n\\n    function claim(address beneficiary, bytes calldata data, bytes calldata authsig, bytes calldata claimsig) public override virtual returns(address issuer, address claimant) {\\n        (issuer, claimant) = super.claim(beneficiary, data, authsig, claimsig);\\n        uint256 claimNonce = abi.decode(data, (uint256));\\n        if(nonces[issuer].get(claimNonce)) {\\n            revert NonceAlreadyUsed(claimNonce);\\n        }\\n        nonces[issuer].set(claimNonce);\\n    }\\n\\n    function nonce(address issuer, uint256 _nonce) public view returns(bool) {\\n        return nonces[issuer].get(_nonce);\\n    }\\n\\n    function isExecutable(address issuer, address claimant, bytes calldata data) public override virtual view returns(bool) {\\n        uint64 claimNonce = abi.decode(data, (uint64));\\n        return !nonces[issuer].get(claimNonce) && super.isExecutable(issuer, claimant, data);\\n    }\\n}\\n\",\"keccak256\":\"0xe5487928cfb72507995fb2173e9d47f0e41bf93d04a915f97ccfd42c58a29473\",\"license\":\"MIT\"},\"contracts/executors/ERC20Executor.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\nimport \\\"../BaseValidator.sol\\\";\\nimport \\\"@openzeppelin/contracts/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport \\\"@openzeppelin/contracts/contracts/utils/Base64.sol\\\";\\nimport \\\"@ensdomains/buffer/contracts/Buffer.sol\\\";\\nimport \\\"solidity-cborutils/contracts/CBOR.sol\\\";\\n\\n/**\\n * @dev A Validator mixin that sends ERC20 tokens from an allowance.\\n */\\nabstract contract ERC20Executor is BaseValidator {\\n    using CBOR for Buffer.buffer;\\n\\n    function tokenInfo(bytes calldata data) public virtual view returns(address token, uint256 amount);\\n\\n    function claim(address beneficiary, bytes calldata data, bytes calldata authsig, bytes calldata claimsig) public override virtual returns(address issuer, address claimant) {\\n        (issuer, claimant) = super.claim(beneficiary, data, authsig, claimsig);\\n        (address token, uint256 amount) = tokenInfo(data);\\n        require(IERC20(token).transfer(beneficiary, amount), \\\"Transfer failed\\\");\\n    }\\n\\n    function transfer(address token, address to, uint256 amount) external ownerOnly {\\n        IERC20(token).transfer(to, amount);\\n    }\\n\\n    function isExecutable(address issuer, address claimant, bytes calldata data) public override virtual view returns(bool) {\\n        (address token, uint256 amount) = tokenInfo(data);\\n        return IERC20(token).balanceOf(address(this)) >= amount\\n            && super.isExecutable(issuer, claimant, data);\\n    }\\n\\n    function metadata(address /*issuer*/, address /*claimant*/, bytes calldata claimData) public override virtual view returns(bytes memory) {\\n        Buffer.buffer memory buf;\\n        Buffer.init(buf, 256);\\n\\n        (address token, uint256 amount) = tokenInfo(claimData);\\n        string memory symbol = IERC20Metadata(token).symbol();\\n\\n        buf.startMap();\\n        buf.encodeString(\\\"title\\\");\\n        buf.encodeString(string(abi.encodePacked(\\\"$\\\", symbol, \\\" token transfer\\\")));\\n        buf.encodeString(\\\"token\\\");\\n        buf.encodeBytes(abi.encodePacked(token));\\n        buf.encodeString(\\\"tokentype\\\");\\n        buf.encodeUInt(20);\\n        buf.encodeString(\\\"amount\\\");\\n        buf.encodeUInt(amount);\\n        buf.endSequence();\\n        return buf.buf;\\n    }\\n}\\n\",\"keccak256\":\"0xe728bad8771978f6e5b5907e8f8adde1d46abfbf0a097952b16ac06f189f1541\",\"license\":\"MIT\"},\"contracts/factories/ERC20UniqueNonceValidator.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\nimport \\\"../executors/ERC20Executor.sol\\\";\\nimport \\\"../dedups/UniqueNonceDedup.sol\\\";\\nimport \\\"../auths/IssuerWhitelistAuth.sol\\\";\\nimport \\\"clones-with-immutable-args/ClonesWithImmutableArgs.sol\\\";\\nimport \\\"clones-with-immutable-args/Clone.sol\\\";\\n\\ncontract ERC20UniqueNonceValidator is UniqueNonceDedup, IssuerWhitelistAuth, ERC20Executor, Clone {\\n    address immutable template;\\n\\n    error DelegatecallOnly();\\n\\n    constructor() {\\n        template = address(this);\\n    }\\n\\n    modifier delegatecallOnly() {\\n        if(address(this) == template) {\\n            revert DelegatecallOnly();\\n        }\\n        _;\\n    }\\n\\n    function isOwner(address _owner) public virtual override view delegatecallOnly returns(bool) {\\n        return _owner == _getArgAddress(0) || _owner == _getArgAddress(20);\\n    }\\n\\n    function owner() external view delegatecallOnly returns(address) {\\n        return _getArgAddress(20);\\n    }\\n\\n    function tokenInfo(bytes calldata /*data*/) public virtual override view delegatecallOnly returns(address token, uint256 amount) {\\n        return (_getArgAddress(40), _getArgUint256(60));\\n    }\\n\\n    function isExecutable(address issuer, address claimant, bytes calldata data) public override(ERC20Executor, UniqueNonceDedup, BaseValidator) virtual view returns(bool) {\\n        return super.isExecutable(issuer, claimant, data);\\n    }\\n\\n    function claim(address beneficiary, bytes calldata data, bytes calldata authsig, bytes calldata claimsig) public override(UniqueNonceDedup, ERC20Executor, BaseValidator) delegatecallOnly returns(address issuer, address claimant) {\\n        return super.claim(beneficiary, data, authsig, claimsig);\\n    }\\n\\n    function metadata(address issuer, address claimant, bytes calldata claimData) public override(ERC20Executor, BaseValidator) virtual view returns(bytes memory) {\\n        return super.metadata(issuer, claimant, claimData);\\n    }\\n}\\n\\ncontract ERC20UniqueNonceValidatorFactory {\\n    using ClonesWithImmutableArgs for address;\\n\\n    event Cloned(address indexed creator, uint256 indexed nonce, address instance, address owner, address token, uint256 amount);\\n\\n    ERC20UniqueNonceValidator immutable public implementation;\\n\\n    constructor() {\\n        implementation = new ERC20UniqueNonceValidator();\\n    }\\n\\n    function create(uint256 nonce, address owner, address token, uint256 amount, address[] memory issuers) external returns(ERC20UniqueNonceValidator) {\\n        bytes memory data = abi.encodePacked(address(this), owner, token, amount);\\n        ERC20UniqueNonceValidator instance = ERC20UniqueNonceValidator(address(implementation).clone(data));\\n        instance.addIssuers(issuers);\\n        emit Cloned(msg.sender, nonce, address(instance), owner, token, amount);\\n        return instance;\\n    }\\n}\\n\",\"keccak256\":\"0xbd0ded90720b60ee608124a85593ee7606f3ec9eef5726a2ebd0c64f087c2302\",\"license\":\"MIT\"},\"solidity-cborutils/contracts/CBOR.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.19 < 0.9.0;\\n\\nimport \\\"@ensdomains/buffer/contracts/Buffer.sol\\\";\\n\\nlibrary CBOR {\\n    using Buffer for Buffer.buffer;\\n\\n    uint8 private constant MAJOR_TYPE_INT = 0;\\n    uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\\n    uint8 private constant MAJOR_TYPE_BYTES = 2;\\n    uint8 private constant MAJOR_TYPE_STRING = 3;\\n    uint8 private constant MAJOR_TYPE_ARRAY = 4;\\n    uint8 private constant MAJOR_TYPE_MAP = 5;\\n    uint8 private constant MAJOR_TYPE_TAG = 6;\\n    uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\\n\\n    uint8 private constant TAG_TYPE_BIGNUM = 2;\\n    uint8 private constant TAG_TYPE_NEGATIVE_BIGNUM = 3;\\n\\n    function encodeFixedNumeric(Buffer.buffer memory buf, uint8 major, uint64 value) private pure {\\n        if(value <= 23) {\\n            buf.appendUint8(uint8((major << 5) | value));\\n        } else if(value <= 0xFF) {\\n            buf.appendUint8(uint8((major << 5) | 24));\\n            buf.appendInt(value, 1);\\n        } else if(value <= 0xFFFF) {\\n            buf.appendUint8(uint8((major << 5) | 25));\\n            buf.appendInt(value, 2);\\n        } else if(value <= 0xFFFFFFFF) {\\n            buf.appendUint8(uint8((major << 5) | 26));\\n            buf.appendInt(value, 4);\\n        } else {\\n            buf.appendUint8(uint8((major << 5) | 27));\\n            buf.appendInt(value, 8);\\n        }\\n    }\\n\\n    function encodeIndefiniteLengthType(Buffer.buffer memory buf, uint8 major) private pure {\\n        buf.appendUint8(uint8((major << 5) | 31));\\n    }\\n\\n    function encodeUInt(Buffer.buffer memory buf, uint value) internal pure {\\n        if(value > 0xFFFFFFFFFFFFFFFF) {\\n            encodeBigNum(buf, value);\\n        } else {\\n            encodeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(value));\\n        }\\n    }\\n\\n    function encodeInt(Buffer.buffer memory buf, int value) internal pure {\\n        if(value < -0x10000000000000000) {\\n            encodeSignedBigNum(buf, value);\\n        } else if(value > 0xFFFFFFFFFFFFFFFF) {\\n            encodeBigNum(buf, uint(value));\\n        } else if(value >= 0) {\\n            encodeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(uint256(value)));\\n        } else {\\n            encodeFixedNumeric(buf, MAJOR_TYPE_NEGATIVE_INT, uint64(uint256(-1 - value)));\\n        }\\n    }\\n\\n    function encodeBytes(Buffer.buffer memory buf, bytes memory value) internal pure {\\n        encodeFixedNumeric(buf, MAJOR_TYPE_BYTES, uint64(value.length));\\n        buf.append(value);\\n    }\\n\\n    function encodeBigNum(Buffer.buffer memory buf, uint value) internal pure {\\n      buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_BIGNUM));\\n      encodeBytes(buf, abi.encode(value));\\n    }\\n\\n    function encodeSignedBigNum(Buffer.buffer memory buf, int input) internal pure {\\n      buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_NEGATIVE_BIGNUM));\\n      encodeBytes(buf, abi.encode(uint(-1 - input)));\\n    }\\n\\n    function encodeString(Buffer.buffer memory buf, string memory value) internal pure {\\n        encodeFixedNumeric(buf, MAJOR_TYPE_STRING, uint64(bytes(value).length));\\n        buf.append(bytes(value));\\n    }\\n\\n    function startArray(Buffer.buffer memory buf) internal pure {\\n        encodeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\\n    }\\n\\n    function startMap(Buffer.buffer memory buf) internal pure {\\n        encodeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\\n    }\\n\\n    function endSequence(Buffer.buffer memory buf) internal pure {\\n        encodeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\\n    }\\n}\\n\",\"keccak256\":\"0x8404fc2f42c30d52542eb22f16a860baf81be58f77093bdc8f22f9d3a66ccfe8\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60a060405234801561001057600080fd5b5060405161001d9061004b565b604051809103906000f080158015610039573d6000803e3d6000fd5b506001600160a01b0316608052610058565b61250a806106d483390190565b60805161065b6100796000396000818160400152610138015261065b6000f3fe608060405234801561001057600080fd5b50600436106100365760003560e01c80635c60da1b1461003b578063bd47615c1461008b575b600080fd5b6100627f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200160405180910390f35b6100626100993660046104b1565b6040517fffffffffffffffffffffffffffffffffffffffff00000000000000000000000030606090811b8216602084015286811b8216603484015285901b166048820152605c81018390526000908190607c01604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529190529050600061015e73ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001683610253565b6040517f466fd51c00000000000000000000000000000000000000000000000000000000815290915073ffffffffffffffffffffffffffffffffffffffff82169063466fd51c906101b39087906004016105cb565b600060405180830381600087803b1580156101cd57600080fd5b505af11580156101e1573d6000803e3d6000fd5b50506040805173ffffffffffffffffffffffffffffffffffffffff85811682528b811660208301528a16818301526060810189905290518b93503392507f032be52d8b132fa7fb18fd872d3ada9bbf9bd9648d9fc784351b3fcdce8183629181900360800190a3979650505050505050565b80516040517f3d610000000000000000000000000000000000000000000000000000000000008152603a820160f081811b6002848101919091527f80600b3d3981f30000000000000000000000000000000000000000000000000060048501527f363d3d3761000000000000000000000000000000000000000000000000000000600b8501528401901b601083018190527f603836393d3d3d366100000000000000000000000000000000000000000000006012840152601b8301527f013d730000000000000000000000000000000000000000000000000000000000601d830152606085901b6020808401919091527f5af43d82803e903d91603657fd5bf3000000000000000000000000000000000060348401526000939260458401929186019084604382015b602082106103b957835181526020938401937fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0909201910161037c565b83517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60208490036101000a0119908116825260f088901b91830191825286846000f0985073ffffffffffffffffffffffffffffffffffffffff891661044b576040517febfef18800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b505050505050505092915050565b803573ffffffffffffffffffffffffffffffffffffffff8116811461047d57600080fd5b919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600080600080600060a086880312156104c957600080fd5b8535945060206104da818801610459565b94506104e860408801610459565b935060608701359250608087013567ffffffffffffffff8082111561050c57600080fd5b818901915089601f83011261052057600080fd5b81358181111561053257610532610482565b8060051b6040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0603f8301168101818110858211171561057557610575610482565b60405291825284820192508381018501918c83111561059357600080fd5b938501935b828510156105b8576105a985610459565b84529385019392850192610598565b8096505050505050509295509295909350565b6020808252825182820181905260009190848201906040850190845b8181101561061957835173ffffffffffffffffffffffffffffffffffffffff16835292840192918401916001016105e7565b5090969550505050505056fea2646970667358221220e83f275a1c73a9658c41a48ab28226823fdd75435f245dec8b436ba3e15d3ac164736f6c634300080a003360a060405234801561001057600080fd5b50306080526080516124c5610045600039600081816102c0015281816103b20152818161055001526105e201526124c56000f3fe608060405234801561001057600080fd5b50600436106100d45760003560e01c80638da5cb5b11610081578063c77d85151161005b578063c77d851514610260578063e8b1a9b214610273578063fc85b9e41461028657600080fd5b80638da5cb5b1461020d578063a5c1e8951461023a578063beabacc81461024d57600080fd5b80633b8c450c116100b25780633b8c450c14610179578063466fd51c146101b95780637a453bac146101ce57600080fd5b806301ffc9a7146100d95780632f54bf6e1461014357806338a7543e14610156575b600080fd5b61012e6100e7366004611b1b565b7fffffffff00000000000000000000000000000000000000000000000000000000167f01ffc9a7000000000000000000000000000000000000000000000000000000001490565b60405190151581526020015b60405180910390f35b61012e610151366004611b88565b6102a6565b61012e610164366004611b88565b60016020526000908152604090205460ff1681565b61018c610187366004611be5565b610397565b6040805173ffffffffffffffffffffffffffffffffffffffff93841681529290911660208301520161013a565b6101cc6101c7366004611cf0565b610429565b005b6101e16101dc366004611d9d565b610535565b6040805173ffffffffffffffffffffffffffffffffffffffff909316835260208301919091520161013a565b6102156105c8565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200161013a565b61012e610248366004611ddf565b610649565b6101cc61025b366004611e40565b610660565b6101cc61026e366004611e7c565b61073e565b61012e610281366004611ef1565b610858565b610299610294366004611ddf565b61089f565b60405161013a9190611f73565b60003073ffffffffffffffffffffffffffffffffffffffff7f0000000000000000000000000000000000000000000000000000000000000000161415610318576040517ff56b123b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61032260006108ad565b73ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16148061038f575061036060146108ad565b73ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16145b90505b919050565b6000803073ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016141561040a576040517ff56b123b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b610419898989898989896108f0565b9150915097509795505050505050565b610432336102a6565b610468576040517f1648fd0100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60005b81518110156104fa57600180600084848151811061048b5761048b611f86565b60209081029190910181015173ffffffffffffffffffffffffffffffffffffffff16825281019190915260400160002080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0016911515919091179055806104f281611fe4565b91505061046b565b507faad2373bff58b592b196d090a3ac0afe6726ad45e112affc585f6b8f59c394388160405161052a919061201d565b60405180910390a150565b6000803073ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001614156105a8576040517ff56b123b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6105b260286108ad565b6105bc603c610a2d565b915091505b9250929050565b60003073ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016141561063a576040517ff56b123b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61064460146108ad565b905090565b600061065785858585610a6d565b95945050505050565b610669336102a6565b61069f576040517f1648fd0100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6040517fa9059cbb00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff83811660048301526024820183905284169063a9059cbb906044016020604051808303816000875af1158015610714573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107389190612077565b50505050565b610747336102a6565b61077d576040517f1648fd0100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60005b8181101561081a576000600160008585858181106107a0576107a0611f86565b90506020020160208101906107b59190611b88565b73ffffffffffffffffffffffffffffffffffffffff168152602081019190915260400160002080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00169115159190911790558061081281611fe4565b915050610780565b507f1c0e076cccd8d672f71d51d86a107970e24233bb9b3abd0eacc60c523c76f1a0828260405161084c929190612099565b60405180910390a15050565b73ffffffffffffffffffffffffffffffffffffffff8216600090815260208181526040808320600885901c8452909152812054600160ff84161b1615155b90505b92915050565b606061065785858585610b31565b6000806108e27ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe368181013560f01c90030190565b929092013560601c92915050565b60008061090289898989898989610d8e565b90925090506000806109148a8a610535565b6040517fa9059cbb00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8e81166004830152602482018390529294509092509083169063a9059cbb906044016020604051808303816000875af1158015610990573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109b49190612077565b610a1f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600f60248201527f5472616e73666572206661696c6564000000000000000000000000000000000060448201526064015b60405180910390fd5b505097509795505050505050565b600080610a627ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe368181013560f01c90030190565b929092013592915050565b6000806000610a7c8585610535565b6040517f70a082310000000000000000000000000000000000000000000000000000000081523060048201529193509150819073ffffffffffffffffffffffffffffffffffffffff8416906370a0823190602401602060405180830381865afa158015610aed573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b1191906120f2565b10158015610b265750610b2687878787610e76565b979650505050505050565b6060610b50604051806040016040528060608152602001600081525090565b610b5c81610100610eea565b50600080610b6a8686610535565b9150915060008273ffffffffffffffffffffffffffffffffffffffff166395d89b416040518163ffffffff1660e01b8152600401600060405180830381865afa158015610bbb573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610be3919081019061210b565b9050610bee84610f4f565b60408051808201909152600581527f7469746c650000000000000000000000000000000000000000000000000000006020820152610c2d908590610f5d565b610c5881604051602001610c41919061219f565b60408051601f198184030181529190528590610f5d565b60408051808201909152600581527f746f6b656e0000000000000000000000000000000000000000000000000000006020820152610c97908590610f5d565b6040517fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606085901b166020820152610ce49060340160408051601f198184030181529190528590610f79565b60408051808201909152600981527f746f6b656e7479706500000000000000000000000000000000000000000000006020820152610d23908590610f5d565b610d2e846014610f86565b60408051808201909152600681527f616d6f756e7400000000000000000000000000000000000000000000000000006020820152610d6d908590610f5d565b610d778483610f86565b610d8084610fb0565b505090519695505050505050565b600080610da089898989898989610fbb565b90925090506000610db3888a018a61220b565b73ffffffffffffffffffffffffffffffffffffffff8416600090815260208181526040808320600885901c8452909152902054909150600160ff83161b1615610e2b576040517f91cab50400000000000000000000000000000000000000000000000000000000815260048101829052602401610a16565b73ffffffffffffffffffffffffffffffffffffffff8316600090815260208181526040808320600885901c845290915290208054600160ff84161b1790555097509795505050505050565b600080610e8583850185612224565b73ffffffffffffffffffffffffffffffffffffffff8716600090815260208181526040808320600885901c66ffffffffffffff168452909152902054909150600160ff83161b16158015610ee05750610ee0868686866110c9565b9695505050505050565b604080518082019091526060815260006020820152610f0a60208361224e565b15610f3257610f1a60208361224e565b610f25906020612289565b610f2f90836122a0565b91505b506020828101829052604080518085526000815290920101905290565b610f5a8160056110f7565b50565b610f6a826003835161110c565b610f74828261121b565b505050565b610f6a826002835161110c565b67ffffffffffffffff811115610fa457610fa08282611242565b5050565b610fa08260008361110c565b610f5a8160076110f7565b600080610fce308a8a8a8a8a8a8a611279565b73ffffffffffffffffffffffffffffffffffffffff8216600090815260016020526040902054919350915060ff1661104a576040517fe9d960d800000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff83166004820152602401610a16565b8173ffffffffffffffffffffffffffffffffffffffff1686866040516110719291906122b8565b60405180910390207f6b8cf58e752d5aa35b36c3b9405a653ebb24dbec95beba7ac574a37aa36e724f8b6110a786868e8e61089f565b6040516110b59291906122c8565b60405180910390a397509795505050505050565b73ffffffffffffffffffffffffffffffffffffffff841660009081526001602052604081205460ff16610657565b610f7482601f611fe0600585901b161761147f565b60178167ffffffffffffffff1611611131576107388360e0600585901b16831761147f565b60ff8167ffffffffffffffff161161116f57611158836018611fe0600586901b161761147f565b506107388367ffffffffffffffff831660016114a4565b61ffff8167ffffffffffffffff16116111ae57611197836019611fe0600586901b161761147f565b506107388367ffffffffffffffff831660026114a4565b63ffffffff8167ffffffffffffffff16116111ef576111d883601a611fe0600586901b161761147f565b506107388367ffffffffffffffff831660046114a4565b61120483601b611fe0600586901b161761147f565b506107388367ffffffffffffffff831660086114a4565b604080518082019091526060815260006020820152610896838460000151518485516114d2565b61124d8260c261147f565b50610fa0828260405160200161126591815260200190565b604051602081830303815290604052610f79565b60008060008a878760405161128f9291906122b8565b6040519081900381207f190000000000000000000000000000000000000000000000000000000000000060208301527fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606093841b811660228401527f800000000000000000000000000000000000000000000000000000000000000060368401526037830191909152918c901b9091166057820152606b0160405160208183030381529060405280519060200120905060006113828287878080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152506115da92505050565b905060008c8b8b6040516113979291906122b8565b6040519081900381207f190000000000000000000000000000000000000000000000000000000000000060208301527fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606093841b811660228401526000603684015260378301919091529184901b9091166057820152606b01604051602081830303815290604052805190602001209050600061146b828b8b8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152506115da92505050565b9e929d50919b505050505050505050505050565b60408051808201909152606081526000602082015261089683846000015151846115fe565b6040805180820190915260608152600060208201526114ca84856000015151858561165a565b949350505050565b60408051808201909152606081526000602082015282518211156114f557600080fd5b602085015161150483866122a0565b111561153757611537856115278760200151878661152291906122a0565b6116db565b6115329060026122f7565b6116f2565b6000808651805187602083010193508088870111156115565787860182525b505050602084015b6020841061159657805182526115756020836122a0565b91506115826020826122a0565b905061158f602085612289565b935061155e565b5181517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60208690036101000a019081169019919091161790525083949350505050565b60008060006115e98585611709565b915091506115f681611776565b509392505050565b6040805180820190915260608152600060208201528360200151831061163357611633848560200151600261153291906122f7565b835180516020858301018481535080851415611650576001810182525b5093949350505050565b604080518082019091526060815260006020820152602085015161167e85846122a0565b1115611692576116928561152786856122a0565b600060016116a284610100612454565b6116ac9190612289565b90508551838682010185831982511617815250805184870111156116d05783860181525b509495945050505050565b6000818311156116ec575081610899565b50919050565b81516116fe8383610eea565b50610738838261121b565b6000808251604114156117405760208301516040840151606085015160001a611734878285856119cf565b945094505050506105c1565b82516040141561176a576020830151604084015161175f868383611ac9565b9350935050506105c1565b506000905060026105c1565b600081600481111561178a5761178a612460565b14156117935750565b60018160048111156117a7576117a7612460565b141561180f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601860248201527f45434453413a20696e76616c6964207369676e617475726500000000000000006044820152606401610a16565b600281600481111561182357611823612460565b141561188b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f45434453413a20696e76616c6964207369676e6174757265206c656e677468006044820152606401610a16565b600381600481111561189f5761189f612460565b141561192d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602260248201527f45434453413a20696e76616c6964207369676e6174757265202773272076616c60448201527f75650000000000000000000000000000000000000000000000000000000000006064820152608401610a16565b600481600481111561194157611941612460565b1415610f5a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602260248201527f45434453413a20696e76616c6964207369676e6174757265202776272076616c60448201527f75650000000000000000000000000000000000000000000000000000000000006064820152608401610a16565b6000807f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0831115611a065750600090506003611ac0565b8460ff16601b14158015611a1e57508460ff16601c14155b15611a2f5750600090506004611ac0565b6040805160008082526020820180845289905260ff881692820192909252606081018690526080810185905260019060a0016020604051602081039080840390855afa158015611a83573d6000803e3d6000fd5b5050604051601f19015191505073ffffffffffffffffffffffffffffffffffffffff8116611ab957600060019250925050611ac0565b9150600090505b94509492505050565b6000807f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff831681611aff60ff86901c601b6122a0565b9050611b0d878288856119cf565b935093505050935093915050565b600060208284031215611b2d57600080fd5b81357fffffffff0000000000000000000000000000000000000000000000000000000081168114611b5d57600080fd5b9392505050565b803573ffffffffffffffffffffffffffffffffffffffff8116811461039257600080fd5b600060208284031215611b9a57600080fd5b61089682611b64565b60008083601f840112611bb557600080fd5b50813567ffffffffffffffff811115611bcd57600080fd5b6020830191508360208285010111156105c157600080fd5b60008060008060008060006080888a031215611c0057600080fd5b611c0988611b64565b9650602088013567ffffffffffffffff80821115611c2657600080fd5b611c328b838c01611ba3565b909850965060408a0135915080821115611c4b57600080fd5b611c578b838c01611ba3565b909650945060608a0135915080821115611c7057600080fd5b50611c7d8a828b01611ba3565b989b979a50959850939692959293505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b604051601f8201601f1916810167ffffffffffffffff81118282101715611ce857611ce8611c90565b604052919050565b60006020808385031215611d0357600080fd5b823567ffffffffffffffff80821115611d1b57600080fd5b818501915085601f830112611d2f57600080fd5b813581811115611d4157611d41611c90565b8060051b9150611d52848301611cbf565b8181529183018401918481019088841115611d6c57600080fd5b938501935b83851015611d9157611d8285611b64565b82529385019390850190611d71565b98975050505050505050565b60008060208385031215611db057600080fd5b823567ffffffffffffffff811115611dc757600080fd5b611dd385828601611ba3565b90969095509350505050565b60008060008060608587031215611df557600080fd5b611dfe85611b64565b9350611e0c60208601611b64565b9250604085013567ffffffffffffffff811115611e2857600080fd5b611e3487828801611ba3565b95989497509550505050565b600080600060608486031215611e5557600080fd5b611e5e84611b64565b9250611e6c60208501611b64565b9150604084013590509250925092565b60008060208385031215611e8f57600080fd5b823567ffffffffffffffff80821115611ea757600080fd5b818501915085601f830112611ebb57600080fd5b813581811115611eca57600080fd5b8660208260051b8501011115611edf57600080fd5b60209290920196919550909350505050565b60008060408385031215611f0457600080fd5b611f0d83611b64565b946020939093013593505050565b60005b83811015611f36578181015183820152602001611f1e565b838111156107385750506000910152565b60008151808452611f5f816020860160208601611f1b565b601f01601f19169290920160200192915050565b6020815260006108966020830184611f47565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82141561201657612016611fb5565b5060010190565b6020808252825182820181905260009190848201906040850190845b8181101561206b57835173ffffffffffffffffffffffffffffffffffffffff1683529284019291840191600101612039565b50909695505050505050565b60006020828403121561208957600080fd5b81518015158114611b5d57600080fd5b60208082528181018390526000908460408401835b868110156120e75773ffffffffffffffffffffffffffffffffffffffff6120d484611b64565b16825291830191908301906001016120ae565b509695505050505050565b60006020828403121561210457600080fd5b5051919050565b60006020828403121561211d57600080fd5b815167ffffffffffffffff8082111561213557600080fd5b818401915084601f83011261214957600080fd5b81518181111561215b5761215b611c90565b61216e6020601f19601f84011601611cbf565b915080825285602082850101111561218557600080fd5b612196816020840160208601611f1b565b50949350505050565b7f24000000000000000000000000000000000000000000000000000000000000008152600082516121d7816001850160208701611f1b565b7f20746f6b656e207472616e7366657200000000000000000000000000000000006001939091019283015250601001919050565b60006020828403121561221d57600080fd5b5035919050565b60006020828403121561223657600080fd5b813567ffffffffffffffff81168114611b5d57600080fd5b600082612284577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b500690565b60008282101561229b5761229b611fb5565b500390565b600082198211156122b3576122b3611fb5565b500190565b8183823760009101908152919050565b73ffffffffffffffffffffffffffffffffffffffff831681526040602082015260006114ca6040830184611f47565b6000817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff048311821515161561232f5761232f611fb5565b500290565b600181815b8085111561238d57817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0482111561237357612373611fb5565b8085161561238057918102915b93841c9390800290612339565b509250929050565b6000826123a457506001610899565b816123b157506000610899565b81600181146123c757600281146123d1576123ed565b6001915050610899565b60ff8411156123e2576123e2611fb5565b50506001821b610899565b5060208310610133831016604e8410600b8410161715612410575081810a610899565b61241a8383612334565b807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0482111561244c5761244c611fb5565b029392505050565b60006108968383612395565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fdfea2646970667358221220013a07b675f6784ee19a8831eb747fb2ae031e39e2681c124e0c6eb757e8242c64736f6c634300080a0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100365760003560e01c80635c60da1b1461003b578063bd47615c1461008b575b600080fd5b6100627f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200160405180910390f35b6100626100993660046104b1565b6040517fffffffffffffffffffffffffffffffffffffffff00000000000000000000000030606090811b8216602084015286811b8216603484015285901b166048820152605c81018390526000908190607c01604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529190529050600061015e73ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001683610253565b6040517f466fd51c00000000000000000000000000000000000000000000000000000000815290915073ffffffffffffffffffffffffffffffffffffffff82169063466fd51c906101b39087906004016105cb565b600060405180830381600087803b1580156101cd57600080fd5b505af11580156101e1573d6000803e3d6000fd5b50506040805173ffffffffffffffffffffffffffffffffffffffff85811682528b811660208301528a16818301526060810189905290518b93503392507f032be52d8b132fa7fb18fd872d3ada9bbf9bd9648d9fc784351b3fcdce8183629181900360800190a3979650505050505050565b80516040517f3d610000000000000000000000000000000000000000000000000000000000008152603a820160f081811b6002848101919091527f80600b3d3981f30000000000000000000000000000000000000000000000000060048501527f363d3d3761000000000000000000000000000000000000000000000000000000600b8501528401901b601083018190527f603836393d3d3d366100000000000000000000000000000000000000000000006012840152601b8301527f013d730000000000000000000000000000000000000000000000000000000000601d830152606085901b6020808401919091527f5af43d82803e903d91603657fd5bf3000000000000000000000000000000000060348401526000939260458401929186019084604382015b602082106103b957835181526020938401937fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0909201910161037c565b83517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60208490036101000a0119908116825260f088901b91830191825286846000f0985073ffffffffffffffffffffffffffffffffffffffff891661044b576040517febfef18800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b505050505050505092915050565b803573ffffffffffffffffffffffffffffffffffffffff8116811461047d57600080fd5b919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600080600080600060a086880312156104c957600080fd5b8535945060206104da818801610459565b94506104e860408801610459565b935060608701359250608087013567ffffffffffffffff8082111561050c57600080fd5b818901915089601f83011261052057600080fd5b81358181111561053257610532610482565b8060051b6040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0603f8301168101818110858211171561057557610575610482565b60405291825284820192508381018501918c83111561059357600080fd5b938501935b828510156105b8576105a985610459565b84529385019392850192610598565b8096505050505050509295509295909350565b6020808252825182820181905260009190848201906040850190845b8181101561061957835173ffffffffffffffffffffffffffffffffffffffff16835292840192918401916001016105e7565b5090969550505050505056fea2646970667358221220e83f275a1c73a9658c41a48ab28226823fdd75435f245dec8b436ba3e15d3ac164736f6c634300080a0033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}