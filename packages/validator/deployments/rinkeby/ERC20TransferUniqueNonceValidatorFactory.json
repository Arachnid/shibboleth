{
  "address": "0x6b12A820C2e71d007696bFFF1e6985c6e9080faa",
  "abi": [
    {
      "inputs": [],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "CreateFail",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "creator",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "nonce",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "instance",
          "type": "address"
        }
      ],
      "name": "Cloned",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "nonce",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "address[]",
          "name": "issuers",
          "type": "address[]"
        }
      ],
      "name": "create",
      "outputs": [
        {
          "internalType": "contract ERC20TransferUniqueNonceValidator",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "implementation",
      "outputs": [
        {
          "internalType": "contract ERC20TransferUniqueNonceValidator",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x2089a60515a2c828b54cb9518c1bcf32f838cbc0901e8e9c710c524a974dae4e",
  "receipt": {
    "to": null,
    "from": "0xE0b604208176C9c991A310E242677dfFddd3ab4D",
    "contractAddress": "0x6b12A820C2e71d007696bFFF1e6985c6e9080faa",
    "transactionIndex": 17,
    "gasUsed": "2399629",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xef20b01f3ed01c24f79a083bef4c5359b7fe3d9622abe3d91ae4d2b027117b13",
    "transactionHash": "0x2089a60515a2c828b54cb9518c1bcf32f838cbc0901e8e9c710c524a974dae4e",
    "logs": [],
    "blockNumber": 10061873,
    "cumulativeGasUsed": "4094229",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "7090f1abdc56d876cfcac55473d140db",
  "metadata": "{\"compiler\":{\"version\":\"0.8.10+commit.fc410830\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CreateFail\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"instance\",\"type\":\"address\"}],\"name\":\"Cloned\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"issuers\",\"type\":\"address[]\"}],\"name\":\"create\",\"outputs\":[{\"internalType\":\"contract ERC20TransferUniqueNonceValidator\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"contract ERC20TransferUniqueNonceValidator\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/factories/ERC20TransferUniqueNonceValidator.sol\":\"ERC20TransferUniqueNonceValidatorFactory\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0x61437cb513a887a1bbad006e7b1c8b414478427d33de47c5600af3c748f108da\",\"license\":\"MIT\"},\"@openzeppelin/contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x8de418a5503946cabe331f35fe242d3201a73f67f77aaeb7110acb1f30423aca\",\"license\":\"MIT\"},\"@openzeppelin/contracts/contracts/utils/Base64.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides a set of functions to operate with Base64 strings.\\n */\\nlibrary Base64 {\\n    /**\\n     * @dev Base64 Encoding/Decoding Table\\n     */\\n    string internal constant _TABLE = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n\\n    /**\\n     * @dev Converts a `bytes` to its Bytes64 `string` representation.\\n     */\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        /**\\n         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\\n         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\\n         */\\n        if (data.length == 0) return \\\"\\\";\\n\\n        // Loads the table into memory\\n        string memory table = _TABLE;\\n\\n        // Encoding takes 3 bytes chunks of binary data from `bytes` data parameter\\n        // and split into 4 numbers of 6 bits.\\n        // The final Base64 length should be `bytes` data length multiplied by 4/3 rounded up\\n        // - `data.length + 2`  -> Round up\\n        // - `/ 3`              -> Number of 3-bytes chunks\\n        // - `4 *`              -> 4 characters for each chunk\\n        string memory result = new string(4 * ((data.length + 2) / 3));\\n\\n        assembly {\\n            // Prepare the lookup table (skip the first \\\"length\\\" byte)\\n            let tablePtr := add(table, 1)\\n\\n            // Prepare result pointer, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // Run over the input, 3 bytes at a time\\n            for {\\n                let dataPtr := data\\n                let endPtr := add(data, mload(data))\\n            } lt(dataPtr, endPtr) {\\n\\n            } {\\n                // Advance 3 bytes\\n                dataPtr := add(dataPtr, 3)\\n                let input := mload(dataPtr)\\n\\n                // To write each character, shift the 3 bytes (18 bits) chunk\\n                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\\n                // and apply logical AND with 0x3F which is the number of\\n                // the previous character in the ASCII table prior to the Base64 Table\\n                // The result is then added to the table to get the character to write,\\n                // and finally write it in the result pointer but with a left shift\\n                // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n            }\\n\\n            // When data `bytes` is not exactly 3 bytes long\\n            // it is padded with `=` characters at the end\\n            switch mod(mload(data), 3)\\n            case 1 {\\n                mstore8(sub(resultPtr, 1), 0x3d)\\n                mstore8(sub(resultPtr, 2), 0x3d)\\n            }\\n            case 2 {\\n                mstore8(sub(resultPtr, 1), 0x3d)\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\",\"keccak256\":\"0x1157a957a0fa2c8a8e93be4397ed06e393524fc317d85bbc868f558ee33c80c4\",\"license\":\"MIT\"},\"@openzeppelin/contracts/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\",\"keccak256\":\"0x32c202bd28995dd20c4347b7c6467a6d3241c74c8ad3edcbb610cd9205916c45\",\"license\":\"MIT\"},\"@openzeppelin/contracts/contracts/utils/cryptography/ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        } else if (error == RecoverError.InvalidSignatureV) {\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        // Check the signature length\\n        // - case 65: r,s,v signature (standard)\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else if (signature.length == 64) {\\n            bytes32 r;\\n            bytes32 vs;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                vs := mload(add(signature, 0x40))\\n            }\\n            return tryRecover(hash, r, vs);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \\u00f7 2 + 1, and for v in (302): v \\u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n        if (v != 27 && v != 28) {\\n            return (address(0), RecoverError.InvalidSignatureV);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\",\"keccak256\":\"0x5adb19e266fcbc76fb4f232e6879932859de1fd1023f6aabaf8da3606c824080\",\"license\":\"MIT\"},\"@openzeppelin/contracts/contracts/utils/introspection/ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\",\"keccak256\":\"0xd10975de010d89fd1c78dc5e8a9a7e7f496198085c151648f20cba166b32582b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/contracts/utils/structs/BitMaps.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/structs/BitMaps.sol)\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing uint256 to bool mapping in a compact and efficient way, providing the keys are sequential.\\n * Largelly inspired by Uniswap's https://github.com/Uniswap/merkle-distributor/blob/master/contracts/MerkleDistributor.sol[merkle-distributor].\\n */\\nlibrary BitMaps {\\n    struct BitMap {\\n        mapping(uint256 => uint256) _data;\\n    }\\n\\n    /**\\n     * @dev Returns whether the bit at `index` is set.\\n     */\\n    function get(BitMap storage bitmap, uint256 index) internal view returns (bool) {\\n        uint256 bucket = index >> 8;\\n        uint256 mask = 1 << (index & 0xff);\\n        return bitmap._data[bucket] & mask != 0;\\n    }\\n\\n    /**\\n     * @dev Sets the bit at `index` to the boolean `value`.\\n     */\\n    function setTo(\\n        BitMap storage bitmap,\\n        uint256 index,\\n        bool value\\n    ) internal {\\n        if (value) {\\n            set(bitmap, index);\\n        } else {\\n            unset(bitmap, index);\\n        }\\n    }\\n\\n    /**\\n     * @dev Sets the bit at `index`.\\n     */\\n    function set(BitMap storage bitmap, uint256 index) internal {\\n        uint256 bucket = index >> 8;\\n        uint256 mask = 1 << (index & 0xff);\\n        bitmap._data[bucket] |= mask;\\n    }\\n\\n    /**\\n     * @dev Unsets the bit at `index`.\\n     */\\n    function unset(BitMap storage bitmap, uint256 index) internal {\\n        uint256 bucket = index >> 8;\\n        uint256 mask = 1 << (index & 0xff);\\n        bitmap._data[bucket] &= ~mask;\\n    }\\n}\\n\",\"keccak256\":\"0xc5d14e1780f0ea212b19c07b83c8e51b9dc6903017df71e6de1fae364d724e0d\",\"license\":\"MIT\"},\"clones-with-immutable-args/Clone.sol\":{\"content\":\"// SPDX-License-Identifier: BSD\\npragma solidity ^0.8.4;\\n\\n/// @title Clone\\n/// @author zefram.eth\\n/// @notice Provides helper functions for reading immutable args from calldata\\ncontract Clone {\\n    /// @notice Reads an immutable arg with type address\\n    /// @param argOffset The offset of the arg in the packed data\\n    /// @return arg The arg value\\n    function _getArgAddress(uint256 argOffset)\\n        internal\\n        pure\\n        returns (address arg)\\n    {\\n        uint256 offset = _getImmutableArgsOffset();\\n        assembly {\\n            arg := shr(0x60, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @notice Reads an immutable arg with type uint256\\n    /// @param argOffset The offset of the arg in the packed data\\n    /// @return arg The arg value\\n    function _getArgUint256(uint256 argOffset)\\n        internal\\n        pure\\n        returns (uint256 arg)\\n    {\\n        uint256 offset = _getImmutableArgsOffset();\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            arg := calldataload(add(offset, argOffset))\\n        }\\n    }\\n\\n    /// @notice Reads an immutable arg with type uint64\\n    /// @param argOffset The offset of the arg in the packed data\\n    /// @return arg The arg value\\n    function _getArgUint64(uint256 argOffset)\\n        internal\\n        pure\\n        returns (uint64 arg)\\n    {\\n        uint256 offset = _getImmutableArgsOffset();\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            arg := shr(0xc0, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @notice Reads an immutable arg with type uint8\\n    /// @param argOffset The offset of the arg in the packed data\\n    /// @return arg The arg value\\n    function _getArgUint8(uint256 argOffset) internal pure returns (uint8 arg) {\\n        uint256 offset = _getImmutableArgsOffset();\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            arg := shr(0xf8, calldataload(add(offset, argOffset)))\\n        }\\n    }\\n\\n    /// @return offset The offset of the packed immutable args in calldata\\n    function _getImmutableArgsOffset() internal pure returns (uint256 offset) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            offset := sub(\\n                calldatasize(),\\n                add(shr(240, calldataload(sub(calldatasize(), 2))), 2)\\n            )\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x8f569b077d99ec821c2750c52094b59b3505fb6ca3e6eac9009092bf86c5452d\",\"license\":\"BSD\"},\"clones-with-immutable-args/ClonesWithImmutableArgs.sol\":{\"content\":\"// SPDX-License-Identifier: BSD\\n\\npragma solidity ^0.8.4;\\n\\n/// @title ClonesWithImmutableArgs\\n/// @author wighawag, zefram.eth\\n/// @notice Enables creating clone contracts with immutable args\\nlibrary ClonesWithImmutableArgs {\\n    error CreateFail();\\n\\n    /// @notice Creates a clone proxy of the implementation contract, with immutable args\\n    /// @dev data cannot exceed 65535 bytes, since 2 bytes are used to store the data length\\n    /// @param implementation The implementation contract to clone\\n    /// @param data Encoded immutable args\\n    /// @return instance The address of the created clone\\n    function clone(address implementation, bytes memory data)\\n        internal\\n        returns (address instance)\\n    {\\n        // unrealistic for memory ptr or data length to exceed 256 bits\\n        unchecked {\\n            uint256 extraLength = data.length + 2; // +2 bytes for telling how much data there is appended to the call\\n            uint256 creationSize = 0x43 + extraLength;\\n            uint256 runSize = creationSize - 11;\\n            uint256 dataPtr;\\n            uint256 ptr;\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                ptr := mload(0x40)\\n\\n                // -------------------------------------------------------------------------------------------------------------\\n                // CREATION (11 bytes)\\n                // -------------------------------------------------------------------------------------------------------------\\n\\n                // 3d          | RETURNDATASIZE        | 0                       | \\u2013\\n                // 61 runtime  | PUSH2 runtime (r)     | r 0                     | \\u2013\\n                mstore(\\n                    ptr,\\n                    0x3d61000000000000000000000000000000000000000000000000000000000000\\n                )\\n                mstore(add(ptr, 0x02), shl(240, runSize)) // size of the contract running bytecode (16 bits)\\n\\n                // creation size = 0b\\n                // 80          | DUP1                  | r r 0                   | \\u2013\\n                // 60 creation | PUSH1 creation (c)    | c r r 0                 | \\u2013\\n                // 3d          | RETURNDATASIZE        | 0 c r r 0               | \\u2013\\n                // 39          | CODECOPY              | r 0                     | [0-2d]: runtime code\\n                // 81          | DUP2                  | 0 c  0                  | [0-2d]: runtime code\\n                // f3          | RETURN                | 0                       | [0-2d]: runtime code\\n                mstore(\\n                    add(ptr, 0x04),\\n                    0x80600b3d3981f300000000000000000000000000000000000000000000000000\\n                )\\n\\n                // -------------------------------------------------------------------------------------------------------------\\n                // RUNTIME\\n                // -------------------------------------------------------------------------------------------------------------\\n\\n                // 36          | CALLDATASIZE          | cds                     | \\u2013\\n                // 3d          | RETURNDATASIZE        | 0 cds                   | \\u2013\\n                // 3d          | RETURNDATASIZE        | 0 0 cds                 | \\u2013\\n                // 37          | CALLDATACOPY          | \\u2013                       | [0, cds] = calldata\\n                // 61          | PUSH2 extra           | extra                   | [0, cds] = calldata\\n                mstore(\\n                    add(ptr, 0x0b),\\n                    0x363d3d3761000000000000000000000000000000000000000000000000000000\\n                )\\n                mstore(add(ptr, 0x10), shl(240, extraLength))\\n\\n                // 60 0x38     | PUSH1 0x38            | 0x38 extra              | [0, cds] = calldata // 0x38 (56) is runtime size - data\\n                // 36          | CALLDATASIZE          | cds 0x38 extra          | [0, cds] = calldata\\n                // 39          | CODECOPY              | _                       | [0, cds] = calldata\\n                // 3d          | RETURNDATASIZE        | 0                       | [0, cds] = calldata\\n                // 3d          | RETURNDATASIZE        | 0 0                     | [0, cds] = calldata\\n                // 3d          | RETURNDATASIZE        | 0 0 0                   | [0, cds] = calldata\\n                // 36          | CALLDATASIZE          | cds 0 0 0               | [0, cds] = calldata\\n                // 61 extra    | PUSH2 extra           | extra cds 0 0 0         | [0, cds] = calldata\\n                mstore(\\n                    add(ptr, 0x12),\\n                    0x603836393d3d3d36610000000000000000000000000000000000000000000000\\n                )\\n                mstore(add(ptr, 0x1b), shl(240, extraLength))\\n\\n                // 01          | ADD                   | cds+extra 0 0 0         | [0, cds] = calldata\\n                // 3d          | RETURNDATASIZE        | 0 cds 0 0 0             | [0, cds] = calldata\\n                // 73 addr     | PUSH20 0x123\\u2026         | addr 0 cds 0 0 0        | [0, cds] = calldata\\n                mstore(\\n                    add(ptr, 0x1d),\\n                    0x013d730000000000000000000000000000000000000000000000000000000000\\n                )\\n                mstore(add(ptr, 0x20), shl(0x60, implementation))\\n\\n                // 5a          | GAS                   | gas addr 0 cds 0 0 0    | [0, cds] = calldata\\n                // f4          | DELEGATECALL          | success 0               | [0, cds] = calldata\\n                // 3d          | RETURNDATASIZE        | rds success 0           | [0, cds] = calldata\\n                // 82          | DUP3                  | 0 rds success 0         | [0, cds] = calldata\\n                // 80          | DUP1                  | 0 0 rds success 0       | [0, cds] = calldata\\n                // 3e          | RETURNDATACOPY        | success 0               | [0, rds] = return data (there might be some irrelevant leftovers in memory [rds, cds] when rds < cds)\\n                // 90          | SWAP1                 | 0 success               | [0, rds] = return data\\n                // 3d          | RETURNDATASIZE        | rds 0 success           | [0, rds] = return data\\n                // 91          | SWAP2                 | success 0 rds           | [0, rds] = return data\\n                // 60 0x36     | PUSH1 0x36            | 0x36 sucess 0 rds       | [0, rds] = return data\\n                // 57          | JUMPI                 | 0 rds                   | [0, rds] = return data\\n                // fd          | REVERT                | \\u2013                       | [0, rds] = return data\\n                // 5b          | JUMPDEST              | 0 rds                   | [0, rds] = return data\\n                // f3          | RETURN                | \\u2013                       | [0, rds] = return data\\n\\n                mstore(\\n                    add(ptr, 0x34),\\n                    0x5af43d82803e903d91603657fd5bf30000000000000000000000000000000000\\n                )\\n            }\\n\\n            // -------------------------------------------------------------------------------------------------------------\\n            // APPENDED DATA (Accessible from extcodecopy)\\n            // (but also send as appended data to the delegatecall)\\n            // -------------------------------------------------------------------------------------------------------------\\n\\n            extraLength -= 2;\\n            uint256 counter = extraLength;\\n            uint256 copyPtr = ptr + 0x43;\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                dataPtr := add(data, 32)\\n            }\\n            for (; counter >= 32; counter -= 32) {\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    mstore(copyPtr, mload(dataPtr))\\n                }\\n\\n                copyPtr += 32;\\n                dataPtr += 32;\\n            }\\n            uint256 mask = ~(256**(32 - counter) - 1);\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                mstore(copyPtr, and(mload(dataPtr), mask))\\n            }\\n            copyPtr += counter;\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                mstore(copyPtr, shl(240, extraLength))\\n            }\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                instance := create(0, ptr, creationSize)\\n            }\\n            if (instance == address(0)) {\\n                revert CreateFail();\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x0c6a218a9724ce6d754db22b162600adbdbac41bfe4dd4eecf6b6d77c74eefe7\",\"license\":\"BSD\"},\"contracts/BaseValidator.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\nimport \\\"@openzeppelin/contracts/contracts/utils/introspection/ERC165.sol\\\";\\nimport \\\"@openzeppelin/contracts/contracts/utils/Base64.sol\\\";\\nimport \\\"./ValidatorLib.sol\\\";\\nimport \\\"./IValidator.sol\\\";\\n\\nabstract contract BaseValidator is IValidator, ERC165 {\\n    error UnauthorisedIssuer(address issuer);\\n\\n    function isIssuer(address issuer) internal virtual view returns(bool);\\n\\n    function claim(address beneficiary, bytes calldata data, bytes calldata authsig, bytes calldata claimsig) public override virtual returns(address issuer, address claimant) {\\n        (issuer, claimant) = ValidatorLib.validate(address(this), beneficiary, data, authsig, claimsig);\\n        if(!isIssuer(issuer)) {\\n            revert UnauthorisedIssuer(issuer);\\n        }\\n        emit ClaimExecuted(keccak256(authsig), issuer, beneficiary, data, authsig, claimsig);\\n    }\\n\\n    function metadata(address issuer, address /*claimant*/, bytes calldata /*data*/) public virtual override view returns(string memory) {\\n        if(!isIssuer(issuer)) {\\n            return string(abi.encodePacked(\\n                \\\"data:application/json;base64,\\\",\\n                Base64.encode(\\\"{\\\\\\\"valid\\\\\\\":false,\\\\\\\"error\\\\\\\":\\\\\\\"Invalid issuer.\\\\\\\"}\\\")\\n            ));\\n        }\\n        return \\\"\\\";\\n    }\\n}\\n\",\"keccak256\":\"0x2a5bcebcaca78b563e9d34e16915648f89b5db1e491e1ce035f06cd858ca3c19\",\"license\":\"MIT\"},\"contracts/IValidator.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\nimport \\\"@openzeppelin/contracts/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Interface for a Shibboleth validator.\\n *      Shibboleth validators are responsible for verifying and acting on single-use claim codes issued by offchain authorities.\\n */\\ninterface IValidator is IERC165 {\\n    /**\\n     * @dev Executes a claim transaction as specified in https://gist.github.com/Arachnid/df9c7e3738ee76bf171c46ef38e4f18b\\n     * @param beneficiary The address that the claim should benefit.\\n     * @param data Claim data provided by the issuer.\\n     * @param authsig A signature over the authorisation message, produced by the issuer.\\n     * @param claimsig A signature over the claim message, produced by the client.\\n     * @return issuer The address of the issuer for this claim.\\n     * @return claimant The address of the claimant for this claim.\\n     */\\n    function claim(address beneficiary, bytes calldata data, bytes calldata authsig, bytes calldata claimsig) external returns(address issuer, address claimant);\\n\\n    /**\\n     * @dev Returns metadata explaining a claim.\\n     * @param issuer The address of the issuer.\\n     * @param claimant The account that is entitled to make the claim.\\n     * @param data Claim data provided by the issuer.\\n     * @return A URL that resolves to JSON metadata as described in the spec.\\n     *         Callers must support at least 'data' and 'https' schemes.\\n     */\\n    function metadata(address issuer, address claimant, bytes calldata data) external view returns(string memory);\\n    \\n    event ClaimExecuted(bytes32 indexed claimId, address indexed issuer, address beneficiary, bytes data, bytes authsig, bytes claimsig);\\n}\\n\",\"keccak256\":\"0x307b6337c3bee078e646ad2bcadbf49c0c8192b66b942905a3c0b24a0d4f5950\",\"license\":\"MIT\"},\"contracts/ValidatorLib.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\nimport \\\"@openzeppelin/contracts/contracts/utils/cryptography/ECDSA.sol\\\";\\n\\nlibrary ValidatorLib {\\n  function validate(address validator, address beneficiary, bytes calldata data, bytes calldata authsig, bytes calldata claimsig) internal pure returns(address, address) {\\n        bytes32 claimhash = keccak256(abi.encodePacked(\\n            hex\\\"1900\\\",\\n            validator,\\n            hex\\\"80\\\",\\n            keccak256(authsig),\\n            beneficiary\\n        ));\\n        address claimant = ECDSA.recover(claimhash, claimsig);\\n        bytes32 authhash = keccak256(abi.encodePacked(\\n            hex\\\"1900\\\",\\n            validator,\\n            hex\\\"00\\\",\\n            keccak256(data),\\n            claimant\\n        ));\\n        address issuer = ECDSA.recover(authhash, authsig);\\n        return (issuer, claimant);\\n    }\\n}\\n\",\"keccak256\":\"0xff1916adb246b347fd0f503014938604f3a72bb27ef00e97fbb6ffb9fbdf7ac9\",\"license\":\"MIT\"},\"contracts/auths/IssuerWhitelistAuth.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\nimport \\\"../BaseValidator.sol\\\";\\nimport \\\"@openzeppelin/contracts/contracts/utils/Base64.sol\\\";\\n\\n/**\\n * Abstract implementation of a validator that maintains a whitelist of allowed issuers.\\n */\\nabstract contract IssuerWhitelistAuth is BaseValidator {\\n    mapping(address=>bool) public issuers;\\n\\n    event IssuersAdded(address[] issuers);\\n    event IssuersRemoved(address[] issuers);\\n\\n    error NotAuthorised();\\n\\n    function isOwner(address owner) public virtual view returns(bool);\\n\\n    modifier ownerOnly {\\n        if(!isOwner(msg.sender)) {\\n            revert NotAuthorised();\\n        }\\n        _;\\n    }\\n\\n    function isIssuer(address issuer) internal override virtual view returns(bool) {\\n        return issuers[issuer];\\n    }\\n\\n    function addIssuers(address[] memory _issuers) external ownerOnly {\\n        for(uint256 i = 0; i < _issuers.length; i++) {\\n            issuers[_issuers[i]] = true;\\n        }\\n        emit IssuersAdded(_issuers);\\n    }\\n\\n    function removeIssuers(address[] calldata _issuers) external ownerOnly {\\n        for(uint256 i = 0; i < _issuers.length; i++) {\\n            issuers[_issuers[i]] = false;\\n        }\\n        emit IssuersRemoved(_issuers);\\n    }\\n}\\n\",\"keccak256\":\"0x6c4ddca220fc2908803bef00c06fd19d9669e99b79406990de095984cd8b41ad\",\"license\":\"MIT\"},\"contracts/dedups/UniqueNonceDedup.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\nimport \\\"../BaseValidator.sol\\\";\\nimport \\\"@openzeppelin/contracts/contracts/utils/Base64.sol\\\";\\nimport \\\"@openzeppelin/contracts/contracts/utils/structs/BitMaps.sol\\\";\\n\\n/**\\n * @dev An implementation of a Validator that requires each claim to have a unique nonce,\\n *      encoded as a uint256 in the first 32 bytes of the data field.\\n */\\nabstract contract UniqueNonceDedup is BaseValidator {\\n    using BitMaps for BitMaps.BitMap;\\n\\n    mapping(address=>BitMaps.BitMap) nonces;\\n\\n    error NonceAlreadyUsed(uint256 nonce);\\n\\n    function claim(address beneficiary, bytes calldata data, bytes calldata authsig, bytes calldata claimsig) public override virtual returns(address issuer, address claimant) {\\n        (issuer, claimant) = super.claim(beneficiary, data, authsig, claimsig);\\n        uint256 claimNonce = abi.decode(data, (uint256));\\n        if(nonces[issuer].get(claimNonce)) {\\n            revert NonceAlreadyUsed(claimNonce);\\n        }\\n        nonces[issuer].set(claimNonce);\\n    }\\n\\n    function nonce(address issuer, uint256 _nonce) public view returns(bool) {\\n        return nonces[issuer].get(_nonce);\\n    }\\n\\n    function metadata(address issuer, address claimant, bytes calldata claimData) public override virtual view returns(string memory) {\\n        string memory ret = super.metadata(issuer, claimant, claimData);\\n        if(bytes(ret).length > 0) {\\n            return ret;\\n        }\\n\\n        uint256 claimNonce = abi.decode(claimData, (uint256));\\n        if(nonces[issuer].get(claimNonce)) {\\n            return string(abi.encodePacked(\\n                \\\"data:application/json;base64,\\\",\\n                Base64.encode(\\\"{\\\\\\\"valid\\\\\\\":false,\\\\\\\"error\\\\\\\":\\\\\\\"Nonce already used.\\\\\\\"}\\\")\\n            ));\\n        }\\n        return \\\"\\\";\\n    }\\n}\\n\",\"keccak256\":\"0x6295859361f8d79cdd414652169597e38c721961ae5e5a24cda2779b3e1b01ec\",\"license\":\"MIT\"},\"contracts/executors/ERC20TransferExecutor.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\nimport \\\"../BaseValidator.sol\\\";\\nimport \\\"@openzeppelin/contracts/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport \\\"@openzeppelin/contracts/contracts/utils/Base64.sol\\\";\\nimport \\\"@openzeppelin/contracts/contracts/utils/Strings.sol\\\";\\n\\n/**\\n * @dev A Validator mixin that sends ERC20 tokens from an allowance.\\n */\\nabstract contract ERC20TransferExecutor is BaseValidator {\\n    using Strings for uint256;\\n\\n    function tokenInfo(bytes calldata data) public virtual view returns(address token, address sender, uint256 amount);\\n\\n    function claim(address beneficiary, bytes calldata data, bytes calldata authsig, bytes calldata claimsig) public override virtual returns(address issuer, address claimant) {\\n        (issuer, claimant) = super.claim(beneficiary, data, authsig, claimsig);\\n        (address token, address sender, uint256 amount) = tokenInfo(data);\\n        require(IERC20(token).transferFrom(sender, beneficiary, amount), \\\"Transfer failed\\\");\\n    }\\n\\n    function metadata(address issuer, address claimant, bytes calldata claimData) public override virtual view returns(string memory) {\\n        string memory ret = super.metadata(issuer, claimant, claimData);\\n        if(bytes(ret).length > 0) {\\n            return ret;\\n        }\\n\\n        (address token, address sender, uint256 amount) = tokenInfo(claimData);\\n        uint256 allowance = IERC20(token).allowance(sender, address(this));\\n        string memory symbol = IERC20Metadata(token).symbol();\\n        if(allowance < amount) {\\n            return string(abi.encodePacked(\\n                \\\"data:application/json;base64,\\\",\\n                Base64.encode(\\\"{\\\\\\\"valid\\\\\\\":false,\\\\\\\"error\\\\\\\":\\\\\\\"Insufficient balance.\\\\\\\"}\\\")\\n            ));\\n        }\\n\\n        return string(abi.encodePacked(\\n            \\\"data:application/json;base64,\\\",\\n            Base64.encode(abi.encodePacked(\\n                \\\"{\\\\\\\"valid\\\\\\\":true,\\\\\\\"data\\\\\\\":{\\\\\\\"title\\\\\\\": \\\\\\\"$\\\",\\n                symbol,\\n                \\\" token transfer\\\\\\\", \\\\\\\"tokentype\\\\\\\":20,\\\\\\\"token\\\\\\\":\\\\\\\"\\\",\\n                uint256(uint160(token)).toHexString(20),\\n                \\\"\\\\\\\",\\\\\\\"amount\\\\\\\":\\\\\\\"\\\",\\n                amount.toString(),\\n                \\\"\\\\\\\"}}\\\"\\n            ))\\n        ));\\n    }\\n}\\n\",\"keccak256\":\"0xf73b6b1f2dd37ceab79b4530325ecf7761ae41a1dba14ba7af1acc6989bd1b80\",\"license\":\"MIT\"},\"contracts/factories/ERC20TransferUniqueNonceValidator.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\nimport \\\"../executors/ERC20TransferExecutor.sol\\\";\\nimport \\\"../dedups/UniqueNonceDedup.sol\\\";\\nimport \\\"../auths/IssuerWhitelistAuth.sol\\\";\\nimport \\\"clones-with-immutable-args/ClonesWithImmutableArgs.sol\\\";\\nimport \\\"clones-with-immutable-args/Clone.sol\\\";\\n\\ncontract ERC20TransferUniqueNonceValidator is UniqueNonceDedup, IssuerWhitelistAuth, ERC20TransferExecutor, Clone {\\n    address immutable template;\\n\\n    error DelegatecallOnly();\\n\\n    constructor() {\\n        template = address(this);\\n    }\\n\\n    modifier delegatecallOnly() {\\n        if(address(this) == template) {\\n            revert DelegatecallOnly();\\n        }\\n        _;\\n    }\\n\\n    function isOwner(address _owner) public virtual override view delegatecallOnly returns(bool) {\\n        return _owner == _getArgAddress(0) || _owner == _getArgAddress(20);\\n    }\\n\\n    function owner() external view returns(address) {\\n        return _getArgAddress(20);\\n    }\\n\\n    function tokenInfo(bytes calldata /*data*/) public virtual override view returns(address token, address sender, uint256 amount) {\\n        return (_getArgAddress(40), _getArgAddress(60), _getArgUint256(80));\\n    }\\n\\n    function claim(address beneficiary, bytes calldata data, bytes calldata authsig, bytes calldata claimsig) public override(UniqueNonceDedup, ERC20TransferExecutor, BaseValidator) delegatecallOnly returns(address issuer, address claimant) {\\n        return super.claim(beneficiary, data, authsig, claimsig);\\n    }\\n\\n    function metadata(address issuer, address claimant, bytes calldata claimData) public override(UniqueNonceDedup, ERC20TransferExecutor, BaseValidator) virtual view returns(string memory) {\\n        return super.metadata(issuer, claimant, claimData);\\n    }\\n}\\n\\ncontract ERC20TransferUniqueNonceValidatorFactory {\\n    using ClonesWithImmutableArgs for address;\\n\\n    event Cloned(address creator, uint256 nonce, address instance);\\n\\n    ERC20TransferUniqueNonceValidator immutable public implementation;\\n\\n    constructor() {\\n        implementation = new ERC20TransferUniqueNonceValidator();\\n    }\\n\\n    function create(uint256 nonce, address owner, address token, address sender, uint256 amount, address[] memory issuers) external returns(ERC20TransferUniqueNonceValidator) {\\n        bytes memory data = abi.encodePacked(address(this), owner, token, sender, amount);\\n        ERC20TransferUniqueNonceValidator instance = ERC20TransferUniqueNonceValidator(address(implementation).clone(data));\\n        instance.addIssuers(issuers);\\n        emit Cloned(msg.sender, nonce, address(instance));\\n        return instance;\\n    }\\n}\\n\",\"keccak256\":\"0x534f5694ca64fd6af34ca6a03eff62fb128c27ea683eb036675622dd872fed4d\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60a060405234801561001057600080fd5b5060405161001d9061004b565b604051809103906000f080158015610039573d6000803e3d6000fd5b506001600160a01b0316608052610058565b6123df806106e683390190565b60805161066d61007960003960008181607c0152610147015261066d6000f3fe608060405234801561001057600080fd5b50600436106100365760003560e01c80633761dad81461003b5780635c60da1b14610077575b600080fd5b61004e6100493660046104b4565b61009e565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200160405180910390f35b61004e7f000000000000000000000000000000000000000000000000000000000000000081565b6040517fffffffffffffffffffffffffffffffffffffffff00000000000000000000000030606090811b8216602084015287811b8216603484015286811b8216604884015285901b16605c820152607081018390526000908190609001604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529190529050600061016d73ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001683610256565b6040517f466fd51c00000000000000000000000000000000000000000000000000000000815290915073ffffffffffffffffffffffffffffffffffffffff82169063466fd51c906101c29087906004016105dd565b600060405180830381600087803b1580156101dc57600080fd5b505af11580156101f0573d6000803e3d6000fd5b505060408051338152602081018d905273ffffffffffffffffffffffffffffffffffffffff85168183015290517fa25d207f3bfe2010a919105302735685a86a1981ad33a4fd49dd08f9b82ccdff9350908190036060019150a198975050505050505050565b80516040517f3d610000000000000000000000000000000000000000000000000000000000008152603a820160f081811b6002848101919091527f80600b3d3981f30000000000000000000000000000000000000000000000000060048501527f363d3d3761000000000000000000000000000000000000000000000000000000600b8501528401901b601083018190527f603836393d3d3d366100000000000000000000000000000000000000000000006012840152601b8301527f013d730000000000000000000000000000000000000000000000000000000000601d830152606085901b6020808401919091527f5af43d82803e903d91603657fd5bf3000000000000000000000000000000000060348401526000939260458401929186019084604382015b602082106103bc57835181526020938401937fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0909201910161037f565b83517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60208490036101000a0119908116825260f088901b91830191825286846000f0985073ffffffffffffffffffffffffffffffffffffffff891661044e576040517febfef18800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b505050505050505092915050565b803573ffffffffffffffffffffffffffffffffffffffff8116811461048057600080fd5b919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b60008060008060008060c087890312156104cd57600080fd5b8635955060206104de81890161045c565b95506104ec6040890161045c565b94506104fa6060890161045c565b93506080880135925060a088013567ffffffffffffffff8082111561051e57600080fd5b818a0191508a601f83011261053257600080fd5b81358181111561054457610544610485565b8060051b6040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0603f8301168101818110858211171561058757610587610485565b60405291825284820192508381018501918d8311156105a557600080fd5b938501935b828510156105ca576105bb8561045c565b845293850193928501926105aa565b8096505050505050509295509295509295565b6020808252825182820181905260009190848201906040850190845b8181101561062b57835173ffffffffffffffffffffffffffffffffffffffff16835292840192918401916001016105f9565b5090969550505050505056fea264697066735822122075dd85e11a139bf8bf8b9168afc08ed25423f79d6ef49bf8e3f668e6426135fa64736f6c634300080a003360a060405234801561001057600080fd5b50306080526080516123a86100376000396000818161028b015261037d01526123a86000f3fe608060405234801561001057600080fd5b50600436106100be5760003560e01c80637a453bac11610076578063c77d85151161005b578063c77d85151461022b578063e8b1a9b21461023e578063fc85b9e41461025157600080fd5b80637a453bac146101b85780638da5cb5b146101fe57600080fd5b806338a7543e116100a757806338a7543e146101405780633b8c450c14610163578063466fd51c146101a357600080fd5b806301ffc9a7146100c35780632f54bf6e1461012d575b600080fd5b6101186100d1366004611918565b7fffffffff00000000000000000000000000000000000000000000000000000000167f01ffc9a7000000000000000000000000000000000000000000000000000000001490565b60405190151581526020015b60405180910390f35b61011861013b36600461197e565b610271565b61011861014e36600461197e565b60016020526000908152604090205460ff1681565b6101766101713660046119db565b610362565b6040805173ffffffffffffffffffffffffffffffffffffffff938416815292909116602083015201610124565b6101b66101b1366004611ae6565b6103f4565b005b6101cb6101c6366004611b93565b610500565b6040805173ffffffffffffffffffffffffffffffffffffffff948516815293909216602084015290820152606001610124565b610206610530565b60405173ffffffffffffffffffffffffffffffffffffffff9091168152602001610124565b6101b6610239366004611bd5565b610541565b61011861024c366004611c4a565b61065b565b61026461025f366004611c74565b6106a0565b6040516101249190611d05565b60003073ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001614156102e3576040517ff56b123b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6102ed60006106b9565b73ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16148061035a575061032b60146106b9565b73ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16145b90505b919050565b6000803073ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001614156103d5576040517ff56b123b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6103e4898989898989896106fc565b9150915097509795505050505050565b6103fd33610271565b610433576040517f1648fd0100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60005b81518110156104c557600180600084848151811061045657610456611d38565b60209081029190910181015173ffffffffffffffffffffffffffffffffffffffff16825281019190915260400160002080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0016911515919091179055806104bd81611d96565b915050610436565b507faad2373bff58b592b196d090a3ac0afe6726ad45e112affc585f6b8f59c39438816040516104f59190611dcf565b60405180910390a150565b600080600061050f60286106b9565b610519603c6106b9565b610523605061084d565b9250925092509250925092565b600061053c60146106b9565b905090565b61054a33610271565b610580576040517f1648fd0100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60005b8181101561061d576000600160008585858181106105a3576105a3611d38565b90506020020160208101906105b8919061197e565b73ffffffffffffffffffffffffffffffffffffffff168152602081019190915260400160002080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00169115159190911790558061061581611d96565b915050610583565b507f1c0e076cccd8d672f71d51d86a107970e24233bb9b3abd0eacc60c523c76f1a0828260405161064f929190611e29565b60405180910390a15050565b73ffffffffffffffffffffffffffffffffffffffff8216600090815260208181526040808320600885901c8452909152812054600160ff84161b1615155b9392505050565b60606106ae8585858561088d565b90505b949350505050565b6000806106ee7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe368181013560f01c90030190565b929092013560601c92915050565b60008061070e89898989898989610aaf565b9092509050600080806107218b8b610500565b9250925092508273ffffffffffffffffffffffffffffffffffffffff166323b872dd838e846040518463ffffffff1660e01b81526004016107909392919073ffffffffffffffffffffffffffffffffffffffff9384168152919092166020820152604081019190915260600190565b6020604051808303816000875af11580156107af573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107d39190611e82565b61083e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600f60248201527f5472616e73666572206661696c6564000000000000000000000000000000000060448201526064015b60405180910390fd5b50505097509795505050505050565b6000806108827ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe368181013560f01c90030190565b929092013592915050565b6060600061089d86868686610b97565b8051909150156108ae5790506106b1565b60008060006108bd8787610500565b6040517fdd62ed3e00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8084166004830152306024830152939650919450925060009185169063dd62ed3e90604401602060405180830381865afa15801561093a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061095e9190611ea4565b905060008473ffffffffffffffffffffffffffffffffffffffff166395d89b416040518163ffffffff1660e01b8152600401600060405180830381865afa1580156109ad573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526109d59190810190611ebd565b905082821015610a2c57610a006040518060600160405280602f81526020016122ae602f9139610c6c565b604051602001610a109190611f51565b60405160208183030381529060405296505050505050506106b1565b610a8081610a5173ffffffffffffffffffffffffffffffffffffffff88166014610dc0565b610a5a86611003565b604051602001610a6c93929190611f96565b604051602081830303815290604052610c6c565b604051602001610a909190611f51565b6040516020818303038152906040529650505050505050949350505050565b600080610ac189898989898989611135565b90925090506000610ad4888a018a6120cc565b73ffffffffffffffffffffffffffffffffffffffff8416600090815260208181526040808320600885901c8452909152902054909150600160ff83161b1615610b4c576040517f91cab50400000000000000000000000000000000000000000000000000000000815260048101829052602401610835565b73ffffffffffffffffffffffffffffffffffffffff8316600090815260208181526040808320600885901c845290915290208054600160ff84161b1790555097509795505050505050565b60606000610ba786868686611242565b805190915015610bb85790506106b1565b6000610bc6848601866120cc565b73ffffffffffffffffffffffffffffffffffffffff8816600090815260208181526040808320600885901c8452909152902054909150600160ff83161b1615610c5257610c2a6040518060600160405280602d8152602001612346602d9139610c6c565b604051602001610c3a9190611f51565b604051602081830303815290604052925050506106b1565b505060408051602081019091526000815295945050505050565b6060815160001415610c8c57505060408051602081019091526000815290565b60006040518060600160405280604081526020016122dd6040913990506000600384516002610cbb91906120e5565b610cc5919061212c565b610cd0906004612140565b67ffffffffffffffff811115610ce857610ce8611a86565b6040519080825280601f01601f191660200182016040528015610d12576020820181803683370190505b509050600182016020820185865187015b80821015610d7e576003820191508151603f8160121c168501518453600184019350603f81600c1c168501518453600184019350603f8160061c168501518453600184019350603f8116850151845350600183019250610d23565b5050600386510660018114610d9a5760028114610dad57610db5565b603d6001830353603d6002830353610db5565b603d60018303535b509195945050505050565b60606000610dcf836002612140565b610dda9060026120e5565b67ffffffffffffffff811115610df257610df2611a86565b6040519080825280601f01601f191660200182016040528015610e1c576020820181803683370190505b5090507f300000000000000000000000000000000000000000000000000000000000000081600081518110610e5357610e53611d38565b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a9053507f780000000000000000000000000000000000000000000000000000000000000081600181518110610eb657610eb6611d38565b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a9053506000610ef2846002612140565b610efd9060016120e5565b90505b6001811115610f9a577f303132333435363738396162636465660000000000000000000000000000000085600f1660108110610f3e57610f3e611d38565b1a60f81b828281518110610f5457610f54611d38565b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a90535060049490941c93610f938161217d565b9050610f00565b508315610699576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820181905260248201527f537472696e67733a20686578206c656e67746820696e73756666696369656e746044820152606401610835565b60608161104357505060408051808201909152600181527f3000000000000000000000000000000000000000000000000000000000000000602082015290565b8160005b811561106d578061105781611d96565b91506110669050600a8361212c565b9150611047565b60008167ffffffffffffffff81111561108857611088611a86565b6040519080825280601f01601f1916602001820160405280156110b2576020820181803683370190505b5090505b84156106b1576110c76001836121b2565b91506110d4600a866121c9565b6110df9060306120e5565b60f81b8183815181106110f4576110f4611d38565b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a90535061112e600a8661212c565b94506110b6565b600080611148308a8a8a8a8a8a8a6112d6565b73ffffffffffffffffffffffffffffffffffffffff8216600090815260016020526040902054919350915060ff166111c4576040517fe9d960d800000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff83166004820152602401610835565b8173ffffffffffffffffffffffffffffffffffffffff1686866040516111eb9291906121dd565b60405180910390207f0a158788e8cf68529772dfddf48c06235a45b4d08e0ec8f32aab01ff153018528b8b8b8b8b8b8b60405161122e9796959493929190612218565b60405180910390a397509795505050505050565b60606112738573ffffffffffffffffffffffffffffffffffffffff1660009081526001602052604090205460ff1690565b6112be5761129860405180606001604052806029815260200161231d60299139610c6c565b6040516020016112a89190611f51565b60405160208183030381529060405290506106b1565b50604080516020810190915260008152949350505050565b60008060008a87876040516112ec9291906121dd565b6040519081900381207f190000000000000000000000000000000000000000000000000000000000000060208301527fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606093841b811660228401527f800000000000000000000000000000000000000000000000000000000000000060368401526037830191909152918c901b9091166057820152606b0160405160208183030381529060405280519060200120905060006113df8287878080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152506114dc92505050565b905060008c8b8b6040516113f49291906121dd565b6040519081900381207f190000000000000000000000000000000000000000000000000000000000000060208301527fffffffffffffffffffffffffffffffffffffffff000000000000000000000000606093841b811660228401526000603684015260378301919091529184901b9091166057820152606b0160405160208183030381529060405280519060200120905060006114c8828b8b8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152506114dc92505050565b9e929d50919b505050505050505050505050565b60008060006114eb8585611500565b915091506114f881611570565b509392505050565b6000808251604114156115375760208301516040840151606085015160001a61152b878285856117cc565b94509450505050611569565b82516040141561156157602083015160408401516115568683836118c6565b935093505050611569565b506000905060025b9250929050565b60008160048111156115845761158461227e565b141561158d5750565b60018160048111156115a1576115a161227e565b1415611609576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601860248201527f45434453413a20696e76616c6964207369676e617475726500000000000000006044820152606401610835565b600281600481111561161d5761161d61227e565b1415611685576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f45434453413a20696e76616c6964207369676e6174757265206c656e677468006044820152606401610835565b60038160048111156116995761169961227e565b1415611727576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602260248201527f45434453413a20696e76616c6964207369676e6174757265202773272076616c60448201527f75650000000000000000000000000000000000000000000000000000000000006064820152608401610835565b600481600481111561173b5761173b61227e565b14156117c9576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602260248201527f45434453413a20696e76616c6964207369676e6174757265202776272076616c60448201527f75650000000000000000000000000000000000000000000000000000000000006064820152608401610835565b50565b6000807f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a083111561180357506000905060036118bd565b8460ff16601b1415801561181b57508460ff16601c14155b1561182c57506000905060046118bd565b6040805160008082526020820180845289905260ff881692820192909252606081018690526080810185905260019060a0016020604051602081039080840390855afa158015611880573d6000803e3d6000fd5b5050604051601f19015191505073ffffffffffffffffffffffffffffffffffffffff81166118b6576000600192509250506118bd565b9150600090505b94509492505050565b6000807f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8316816118fc60ff86901c601b6120e5565b905061190a878288856117cc565b935093505050935093915050565b60006020828403121561192a57600080fd5b81357fffffffff000000000000000000000000000000000000000000000000000000008116811461069957600080fd5b803573ffffffffffffffffffffffffffffffffffffffff8116811461035d57600080fd5b60006020828403121561199057600080fd5b6106998261195a565b60008083601f8401126119ab57600080fd5b50813567ffffffffffffffff8111156119c357600080fd5b60208301915083602082850101111561156957600080fd5b60008060008060008060006080888a0312156119f657600080fd5b6119ff8861195a565b9650602088013567ffffffffffffffff80821115611a1c57600080fd5b611a288b838c01611999565b909850965060408a0135915080821115611a4157600080fd5b611a4d8b838c01611999565b909650945060608a0135915080821115611a6657600080fd5b50611a738a828b01611999565b989b979a50959850939692959293505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b604051601f8201601f1916810167ffffffffffffffff81118282101715611ade57611ade611a86565b604052919050565b60006020808385031215611af957600080fd5b823567ffffffffffffffff80821115611b1157600080fd5b818501915085601f830112611b2557600080fd5b813581811115611b3757611b37611a86565b8060051b9150611b48848301611ab5565b8181529183018401918481019088841115611b6257600080fd5b938501935b83851015611b8757611b788561195a565b82529385019390850190611b67565b98975050505050505050565b60008060208385031215611ba657600080fd5b823567ffffffffffffffff811115611bbd57600080fd5b611bc985828601611999565b90969095509350505050565b60008060208385031215611be857600080fd5b823567ffffffffffffffff80821115611c0057600080fd5b818501915085601f830112611c1457600080fd5b813581811115611c2357600080fd5b8660208260051b8501011115611c3857600080fd5b60209290920196919550909350505050565b60008060408385031215611c5d57600080fd5b611c668361195a565b946020939093013593505050565b60008060008060608587031215611c8a57600080fd5b611c938561195a565b9350611ca16020860161195a565b9250604085013567ffffffffffffffff811115611cbd57600080fd5b611cc987828801611999565b95989497509550505050565b60005b83811015611cf0578181015183820152602001611cd8565b83811115611cff576000848401525b50505050565b6020815260008251806020840152611d24816040850160208701611cd5565b601f01601f19169190910160400192915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff821415611dc857611dc8611d67565b5060010190565b6020808252825182820181905260009190848201906040850190845b81811015611e1d57835173ffffffffffffffffffffffffffffffffffffffff1683529284019291840191600101611deb565b50909695505050505050565b60208082528181018390526000908460408401835b86811015611e775773ffffffffffffffffffffffffffffffffffffffff611e648461195a565b1682529183019190830190600101611e3e565b509695505050505050565b600060208284031215611e9457600080fd5b8151801515811461069957600080fd5b600060208284031215611eb657600080fd5b5051919050565b600060208284031215611ecf57600080fd5b815167ffffffffffffffff80821115611ee757600080fd5b818401915084601f830112611efb57600080fd5b815181811115611f0d57611f0d611a86565b611f206020601f19601f84011601611ab5565b9150808252856020828501011115611f3757600080fd5b611f48816020840160208601611cd5565b50949350505050565b7f646174613a6170706c69636174696f6e2f6a736f6e3b6261736536342c000000815260008251611f8981601d850160208701611cd5565b91909101601d0192915050565b7f7b2276616c6964223a747275652c2264617461223a7b227469746c65223a202281527f2400000000000000000000000000000000000000000000000000000000000000602082015260008451611ff4816021850160208901611cd5565b7f20746f6b656e207472616e73666572222c2022746f6b656e74797065223a32306021918401918201527f2c22746f6b656e223a22000000000000000000000000000000000000000000006041820152845161205781604b840160208901611cd5565b7f222c22616d6f756e74223a220000000000000000000000000000000000000000604b92909101918201528351612095816057840160208801611cd5565b7f227d7d000000000000000000000000000000000000000000000000000000000060579290910191820152605a0195945050505050565b6000602082840312156120de57600080fd5b5035919050565b600082198211156120f8576120f8611d67565b500190565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b60008261213b5761213b6120fd565b500490565b6000817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff048311821515161561217857612178611d67565b500290565b60008161218c5761218c611d67565b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0190565b6000828210156121c4576121c4611d67565b500390565b6000826121d8576121d86120fd565b500690565b8183823760009101908152919050565b818352818160208501375060006020828401015260006020601f19601f840116840101905092915050565b73ffffffffffffffffffffffffffffffffffffffff8816815260806020820152600061224860808301888a6121ed565b828103604084015261225b8187896121ed565b905082810360608401526122708185876121ed565b9a9950505050505050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fdfe7b2276616c6964223a66616c73652c226572726f72223a22496e73756666696369656e742062616c616e63652e227d4142434445464748494a4b4c4d4e4f505152535455565758595a6162636465666768696a6b6c6d6e6f707172737475767778797a303132333435363738392b2f7b2276616c6964223a66616c73652c226572726f72223a22496e76616c6964206973737565722e227d7b2276616c6964223a66616c73652c226572726f72223a224e6f6e636520616c726561647920757365642e227da2646970667358221220d927e7b294c50d200f34233a8de9917ea9b7eeeb52b12e452309aa8ce2cb754b64736f6c634300080a0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100365760003560e01c80633761dad81461003b5780635c60da1b14610077575b600080fd5b61004e6100493660046104b4565b61009e565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200160405180910390f35b61004e7f000000000000000000000000000000000000000000000000000000000000000081565b6040517fffffffffffffffffffffffffffffffffffffffff00000000000000000000000030606090811b8216602084015287811b8216603484015286811b8216604884015285901b16605c820152607081018390526000908190609001604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529190529050600061016d73ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001683610256565b6040517f466fd51c00000000000000000000000000000000000000000000000000000000815290915073ffffffffffffffffffffffffffffffffffffffff82169063466fd51c906101c29087906004016105dd565b600060405180830381600087803b1580156101dc57600080fd5b505af11580156101f0573d6000803e3d6000fd5b505060408051338152602081018d905273ffffffffffffffffffffffffffffffffffffffff85168183015290517fa25d207f3bfe2010a919105302735685a86a1981ad33a4fd49dd08f9b82ccdff9350908190036060019150a198975050505050505050565b80516040517f3d610000000000000000000000000000000000000000000000000000000000008152603a820160f081811b6002848101919091527f80600b3d3981f30000000000000000000000000000000000000000000000000060048501527f363d3d3761000000000000000000000000000000000000000000000000000000600b8501528401901b601083018190527f603836393d3d3d366100000000000000000000000000000000000000000000006012840152601b8301527f013d730000000000000000000000000000000000000000000000000000000000601d830152606085901b6020808401919091527f5af43d82803e903d91603657fd5bf3000000000000000000000000000000000060348401526000939260458401929186019084604382015b602082106103bc57835181526020938401937fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0909201910161037f565b83517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60208490036101000a0119908116825260f088901b91830191825286846000f0985073ffffffffffffffffffffffffffffffffffffffff891661044e576040517febfef18800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b505050505050505092915050565b803573ffffffffffffffffffffffffffffffffffffffff8116811461048057600080fd5b919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b60008060008060008060c087890312156104cd57600080fd5b8635955060206104de81890161045c565b95506104ec6040890161045c565b94506104fa6060890161045c565b93506080880135925060a088013567ffffffffffffffff8082111561051e57600080fd5b818a0191508a601f83011261053257600080fd5b81358181111561054457610544610485565b8060051b6040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0603f8301168101818110858211171561058757610587610485565b60405291825284820192508381018501918d8311156105a557600080fd5b938501935b828510156105ca576105bb8561045c565b845293850193928501926105aa565b8096505050505050509295509295509295565b6020808252825182820181905260009190848201906040850190845b8181101561062b57835173ffffffffffffffffffffffffffffffffffffffff16835292840192918401916001016105f9565b5090969550505050505056fea264697066735822122075dd85e11a139bf8bf8b9168afc08ed25423f79d6ef49bf8e3f668e6426135fa64736f6c634300080a0033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}